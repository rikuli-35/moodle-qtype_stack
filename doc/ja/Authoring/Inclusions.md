# インクルード

STACK は、問題間でコードを共有するメカニズムを提供する。例えば、特定のトピックに特化した Maxima 関数の小さなライブラリを問題変数に含めることができる。

(i) 問題間で関数のライブラリを再利用することと (ii) [将来性を考慮したガイドライン](../../en/STACK_question_admin/Future_proof.md) にある「自己完結型教材の原則」の間にはトレードオフがある。これは高度なトピックである。

技術的な注意：現在、ループの検出とセキュリティ検証の理由から、インクルード内のインクルード（入れ子）はサポートされていない。

## インクルードのライフサイクル

現在サポートされているすべてのタイプのインクルードにおいて、インクルードは問題のコンパイル時に行われる。つまり、ソースとなる外部コードは問題がコンパイルされる際に取得され、キャッシュされたコンパイル生成物の中に保持される。コンパイルは、問題が保存された後、あるいはキャッシュが削除された後の、その問題の最初の使用時に実行される。

インクルードのロジックは、外部ソース資料の変更を追跡しない。再度取得したい場合は、キャッシュを削除するか、問題を編集して保存し直し、問題を再コンパイルする必要がある。

エクスポート時には、ソースアドレスのみがエクスポートされる。エクスポートされた教材は、インポートする側の環境からそのアドレスにアクセスできる場合にのみ機能する。

## テキスト内のインクルード

より単純なインクルードタイプは CASText2 の インクルージョンブロックで、これは単に指定されたアドレスからの CASText2 コードをブロックの位置に配置するものである。コンテキスト（記述されている場所）とインクルードされるコードのフォーマットには注意が必要である点に留意すること。インクルードのロジックは、コードがコンテキストと同じフォーマットであると仮定する。そのため、もしインクルードされるコンテンツがMarkdown形式で、それをHTMLコンテキストに直接インクルードした場合、トラブルの原因となる可能性がある。

典型的なユースケースとしては、特定の変数が描画用のパラメータを含んでいることを期待するJSXGraphやGeoGebraの描画ロジックを用意する場合が挙げられる。その場合、例えば以下のように、描画ロジックをインクルードする前に、それらのパラメータに確実に値を設定するだけで済む。

```text
まず、先に定義した値を用いてプロットを描画する。
[[include src="http://example.com/fragments/myplot.txt"/]]

次に、同じ描画ロジックをインクルードするが、パラメータを変更して別のものを描画する。
[[define plot_fun="theotherfun" plot_param1="something"/]]
[[include src="http://example.com/fragments/myplot.txt"/]]

```

インクルードされるコンテンツは、コンテキストとは異なる形式（Markdown など）である可能性があるため、インクルードされるコンテンツ自身がその形式を定義することが推奨される。例えば、新しい形式制御ブロック `[[moodleformat]]`, `[[htmlformat]]`, `[[markdownformat]]` のいずれかでコンテンツを囲むことで、どのような形式のコンテンツも他の形式のコンテンツ内にインクルードできるようになる。現時点では、数式モードの識別機能は、これらのコンテキスト切り替えのすべてを完全には理解できていないことに注意すること。

## CAS ロジック内のインクルード

コードを問題変数やフィードバック変数にインクルードすることもできる。
このタイプのインクルードは、問題作成者がコード内のその場所に直接書いたのとまったく同様に機能する。
もしこのタイプのインクルードを if 文の中に書いた場合、それは単に if 文の中に展開されて記述される。`if` はそれが実行されるかどうかを決定するだけであり、インクルードしたコンテンツのデータ容量や通信リソースはその分だけ消費されることになる。

インクルードされるコンテンツは、以下にある通常のSTACKの変数が満たすすべてのルールに従う必要がある。

1. 大量のコードはパフォーマンスに影響を与える。内部の Maxima コードはプリコンパイルされているが、問題変数は実行時に解釈される。
2. インクルードされたコード内で定義されたすべての識別子は、直接入力した場合と同様にチェックの対象となる。
3. コード内の識別子は、学生にとっての禁止ワードとしてマークされる。したがって、問題間でロジックを共有する際、識別子の選択には特に注意が必要である。学生が他の問題で入力するかもしれない名前は使用しないこと。
4. コードは学生が問題を使用するときではなく、問題を保存するときにロードされる。したがって、コードは問題内にキャッシュされる。外部ライブラリへの更新は既存の問題には影響しない。そのキャッシュは、(a) STACK プラグインを更新する（すべてのキャッシュ/コンパイルされた問題をクリアする）、(b) 問題を保存する（コードを再度ダウンロードする）のいずれかを行わない限り無効にならない。

現時点では、不要なコードを削除するための「ツリーシェイキング（tree-shaking）」は行われないことに注意すること。使用しない関数を含む巨大なライブラリをインクルードした場合でも、問題はそれらの関数をCASにロードしなければならず、処理に時間がかかる可能性がある。多くの問題で使用されるライブラリがある場合は、それらをSTACK本体へ提供することを検討すること。

外部 CAS コードをインクルードするには、文字列引数を指定して `stack_include()` 関数を呼び出す。引数は、コードの URL を含む生の文字列でなければならない。URLの文字列が格納された変数を参照することはできない。例えば

```maxima
a: rand(3)+2;
/* 表示を調整するためのロジックを読み込む */
stack_include("http://example.com/fragments/mytexputrules.txt");
/* 特殊なランダム化関数を組み込む */
stack_include("http://example.com/fragments/mymatrixrand.txt");
m: mymatrix_rand_integer_invertible(a);
```

`stack_include()` で評価フラグを使用することはできない。インクルードされるコード自体がフラグを含んでいる場合があるが、インクルードの呼び出しによって、インクルードされるすべてのコンテンツにフラグを適用することはできない。

関数 `stack_include_contrib()` は、GitHub の master ブランチにある [STACK maxima contrib フォルダ](https://github.com/maths/moodle-qtype_stack/tree/master/stack/maxima/contrib) に含まれるファイルをロードする。
具体的には、`stack_include_contrib()` の引数の先頭に次の URL が付加される：
`https://raw.githubusercontent.com/maths/moodle-qtype_stack/master/stack/maxima/contrib/`

したがって、以下は完全に等価である。

```maxima
stack_include("https://raw.githubusercontent.com/maths/moodle-qtype_stack/master/stack/maxima/contrib/validators.mac");
stack_include_contrib("validators.mac");
```

注意：

1. contrib フォルダ内のファイルは小さく、安定したものに保つよう努めている。
2. 頻繁に使用される提供コードについては、適切な時期にSTACK本体へ移動させることを意図している。その時点で、自動翻訳に対応できるよう言語文字列のローカライズを行う。
3. 命名規則については開発者に連絡すること。例えば、外部の検証関数は関数名を `validator_` で始める必要がある。
4. ライブラリをサーバー上でローカルに使用したい場合は、ファイル名の先頭に `contribl://` を付けること。例えば `stack_include("contribl://matchlib.mac");` は GitHub 上のファイルではなく、ローカルファイルをロードする。これは主に、コードが master ブランチにプッシュされる前のローカル開発のための機能である。実際の運用中の問題でこれを使用することは推奨しない。

### サンドボックスでのテスト

`stack_include()` にはMaxima側に相当する機能が存在しないことに注意すること。そのため、デバッグのために問題変数をそのままMaximaにコピー＆ペーストすることはできない。インクルード操作は、手動で行う必要がある。

サンドボックスをセットアップする際に、 `stack_include_contrib()` は、ローカルの STACK ファイルからパッケージを読み込む。ローカルマシン上の提供コードおよび他のファイルのバージョンが古くなっている可能性があるため、サンドボックス内のコードが最新のものであるか必ず確認すること。

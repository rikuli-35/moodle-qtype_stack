# 問題作成時の検証エラー

このドキュメントでは、問題の作成中、特に問題の検証や保存の際に表示される可能性のある特定のエラーについて説明する。問題作成者のためのエラー検出機能は常に改善されている。そのため、アップグレード時に新たなエラーが表示されるようになったり、以前は機能していた教材が動作しなくなったりする可能性がある。

過去には許可されていた操作が現在は禁止されている場合があるが、これには正当な理由がある。状況によっては、記述方法を変更することで、検証システムのエラー判定を回避（解消）できることがある。

アドバイス：

1. Maxima の一部としてすでに定義されている関数名や定数を再定義してはいけない。
2. 関数と変数に同じ名前を使用しない。
3. 複雑な置換は避ける。
4. 入力（解答欄）の名前となっている変数を再定義しない。
5. 置換を行うには `ev` の代わりに `subst` や `at` を使用する。

## 禁止されている関数と変数

基盤システムに影響を与える関数のいくつかは、環境の保護のため、あるいは過度な負荷を避けるために禁止されている。また、戻り値の仕様により無効化されているものもある。同様に、基盤システムの状態を表す一部の変数/定数についても、参照や変更が禁止されているものがある。もし、単なる識別子の衝突でエラーが出ている場合は、別の名前を使用する。そうでない場合は、システムの仕様である。

## 内部関数の再定義

一部の関数は中核機能の一部であり、システムはその挙動に依存している。例えば、リストに対する `append()` の動作を再定義してしまうと、システム全体に重大な影響を及ぼす。そのため、特定の名前を持つ関数を（再）定義することは禁止されている。自身の関数には他の名前を自由に使用する必要がある。注意点として、すべての内部関数やそれらが使用する関数がこの制限によってブロックされているわけではない。将来的にブロックされる可能性もあるし、ロジックを調整するために再定義可能なまま残されるものもあるであろう。

基本的には、Maximaの一部として既に定義されている関数名や定数を再定義しようとしないことを推奨する。

## 不明確な置換、またはその他の置換

コード内で値の置換を行う際、その置換対象となる識別子が、後に関数名として使用されるものである場合、処理が複雑になる可能性がある。関数と変数には、同じ名前を使用しないようにするべきである。
また、置換ルールを複雑な手順で生成すると、システムは安全のため、式に含まれるすべての変数が未知の値に書き換えられる可能性があるとみなして処理する。置換ルールの生成方法を単純化すれば、この判定を回避できる。

なお、4.4 でセキュリティシステムが変更された後、これらの問題はかなり稀になった。新しいシステムではこれらのエラーを見ることはないはずである。

### 例 1

```maxima
v:1; /* particular case of rand([1,2]) */
trig:[sin,cos][v];
sub:[(sin(x))^2=1-(cos(x))^2,(cos(x))^2=1-(sin(x))^2][v];
f:(trig(x))^3;
df:diff(f,x);
df_simp:subst(sub,df);
```

これは以下のエラーメッセージを生成する。
> The function name "sin" is potentially redefined in unclear substitutions. The function name "diff" is potentially redefined in unclear substitutions.

ここでの問題は、`sub` が複雑な式であるため、検証システムがこのコードが何か疑わしいことをしていないと確認できないことである。

`subst` ではなく `ev` を使用してみる価値があるかもしれない。この例では、最後の行を以下のように変更すると、問題は再び動作する。

```maxima
df_simp:ev(df, sub);
```

### 例 2

```maxima
solution : rhs(ode2(eqn,y,x));
vars : delete(x,listofvars(solution));

TAns11 : subst([vars[1]=A,vars[2]=B],solution);
TAns12 : subst([vars[2]=A,vars[1]=B],solution);
```

ここでエラーメッセージは、`solution` に入るほぼ全ての要素が不明確な置換で再定義される可能性があると警告する。上記のコードが行っていることは、CAS で微分方程式を解き、その解で使用されている積分定数の名前を取得することである。方程式の形によっては定数が複数になることもあるが、この例では常に2つの定数（`%k1` と `%k2`）が存在する。もし定数が1つだけであれば、おそらく `%c` という名前になるであろう。実際にどのような名前が使われるかを確認する必要がある。

この例であえて定数名を取得しているのには理由がある。それは、出題者が学生に対し、定数として A と B を使うよう強制したかったからである。さらに、定数の順序（どちらを A とし、どちらを B とするか）の選び方は2通りあるため、その両方に対応した正解を作成している。ここで問題となるのは、定数の置換処理において、検証システムからは直接見えないリストから名前を取得している点である（これが「不明瞭な置換」と判定される）。これには2つの解決策がある。第一に、`SubstEquiv` 評価関数を使用する方法である。この関数は任意の定数名の使用を許容するため、もし定数名の指定（AやBの使用）にこだわらず、単に正しい定数が使われていることさえ確認できればよいのであれば、この方法が有効である。ただし、その場合でも模範解答に `%k1` のようなCAS形式の定数がそのまま表示されてしまい、見た目が不自然になる。そのため、結局は見栄えを良くするために定数を置換する処理が必要になるであろう。第二に、定数名をハードコーディング（直接記述）する方法である。今回のケースでは、生成される定数名は常に同じ（%k1 と %k2）であるため、以下のように直接記述しても問題にはならない。

```maxima
solution : rhs(ode2(eqn,y,x));

TAns11 : subst([%k1=A,%k2=B],solution);
TAns12 : subst([%k2=A,%k1=B],solution);
```

## 学生の解答の利用

バージョン4.3以降、学生の解答が格納されている変数への書き込みは禁止された。保存したい値がある場合は、単に他の有効な変数を使用する必要がある。また、学生の入力を直接関数名として使用することも禁止されている。もしそのような処理が必要な場合は、ロジックを条件分岐に書き換える必要がある。この制限は多肢選択問題（MCQ）の入力にも適用される。

```maxima
/* このような書き方は禁止されています。 */
val: ans1(4);

/* 代わりに以下のように記述してください。 */
if is(ans1=sqrt) then
 val: sqrt(4)
else if(ans1=sin) then
 val: sin(4)
...

```

## 4.4 での `ev`

STACK 4.4 の新しいセキュリティモデルでは、実行順序が変更されたため、`ev` が Maxima の `ev` の挙動と完全には一致しなくなった。ほとんどの用途では気づかない程度であるが、期待どおりに動作しない状況もある。一般的に注意すべき状況は以下の通りである。

 1. `ev` の中に `expand` を置き、同じ `ev` 内で置換を行う場合：

 ```maxima
 /* これは置換の前に展開が行われる可能性があります */
 simp:false;
 tmp:ev(expand(x^3),x=x+1);

 /* 代わりに展開の前に置換を行ってください */
 tmp: ev(x^3,x=x+1);
 tmp: ev(expand(tmp));
 ```

 1. 一般に、ターゲットとなる式にセキュリティ検証を必要とする呼び出しが含まれている場合、置換が行われるのが遅すぎる可能性がある。

 これに対処するための推奨される方法は、`subst` または `at` を使用して置換を行い、評価に関連する修正は `ev` で別個に適用することである。

 1. `noeval` 評価フラグの使用は機能しない可能性がある。

 一般に、このフラグは STACK では役に立ちそうにない。必要だと思われる場合は、名詞化や他の手段を検討すること。

場合によっては、単純に `eval` を追加のフラグとして `ev` 呼び出しに加えることが可能である。ただし、これが可能なのは、呼び出し内のすべての置換において、その左辺が右辺に含まれていない場合（自己参照的な置換でない場合）に限られる。

これらすべては評価フラグにも適用されることに注意する。

```maxima
/* これらは等価です */
tmp: a+1,a=2;
tmp: ev(a+1,a=2);
```

## いくつかの推奨事項

特定の項目の検証プロセスでは、識別子の依存関係グラフが評価される。そのため、これらのグラフを小さく保つことができれば、処理はより高速になる傾向がある。これを実現するためには、可能な限り同じ変数の再定義を避け、必要に応じて新しい変数を作成するようにする。つまり、すべての計算で `tmp` のような一時変数を使い回すことは避けるべきである。変数を使い回すと、その変数の依存関係グラフが非常に大きくなり、処理速度の低下を招く恐れがある。少数の巨大なグラフよりも、多数の小さなグラフの方が処理は速くなる。また、グラフが巨大化すると、グラフ内のあるノードの特性が原因で、他のノードが特定の処理（例：関数識別子としての使用など）を行えなくなる可能性がある。

同様に、問題内で複数の異なる「型」のオブジェクトに対して、同じ変数名を使い回すことも避けるべきである。例えば、`A` を行列として定義したならば、そのまま行列として扱うべきである。リストや関数などに変更しないことで、保存時や、インポート/アップグレード後の初回実行時に行われる検証処理を高速化できる。

ローカルスコープ変数を定義するために `local()` を使用する場合は、常に `block` の最初（ただし、ブロック変数のリスト宣言を使用する場合は同じブロック内で `local()` を使用してはいけない）、または `lambda` の先頭（引数の後）で呼び出すこと。このように配置することで、依存グラフの構築ロジックがグラフの切れ目を特定し、スコープを正しく分離できるようになる。変数が使用された後に `local` を呼び出すとロジックを混乱させる。そのような特殊なケースへの対応を行う予定はない。

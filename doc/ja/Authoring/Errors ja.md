# 問題作成時の検証エラー

このドキュメントでは、問題の作成中、特に問題の検証や保存の際に表示される可能性のある特定のエラーについて説明します。私たちは問題作成者のためのエラー検出機能を常に改善しています。そのため、アップグレード時に新たなエラーが表示されるようになったり、以前は機能していた教材が動作しなくなったりする可能性があります。

過去には許可されていた操作が現在は禁止されている場合がありますが、これには正当な理由があります。状況によっては、記述方法を変更することで、検証システムのエラー判定を回避（解消）できることがあります。

アドバイス：

1. Maxima の一部としてすでに定義されている関数名や定数を再定義しようとしないでください。
2. 関数と変数に同じ名前を使用しないでください。
3. 複雑な置換は避けてください。
4. 入力（解答欄）の名前となっている変数を再定義しないでください。
5. 置換を行うには `ev` の代わりに `subst` や `at` を使用してください。

## 禁止されている関数と変数

基盤システムに影響を与える関数のいくつかは、環境の保護（セキュリティ）のため、あるいは過度な負荷を避けるために禁止されています。また、戻り値の仕様により無効化されているものもあります。同様に、基盤システムの状態を表す一部の変数/定数についても、参照や変更が禁止されているものがあります。もし、単なる識別子の衝突（名前の重複）でエラーが出ている場合は、別の名前を使用してください。そうでない場合は、システムの仕様ですのでご了承ください。

## 内部関数の再定義

一部の関数は中核機能の一部であり、システムはその挙動に依存しています。例えば、リストに対する `append()` の動作を再定義してしまうと、システム全体に重大な影響を及ぼします。そのため、特定の名前を持つ関数を（再）定義することは禁止されています。ご自身の関数には他の名前を自由に使用してください。注意点として、すべての内部関数やそれらが使用する関数がこの制限によってブロックされているわけではありません。将来的にブロックされる可能性もありますし、ロジックを調整するために再定義可能なまま残されるものもあるでしょう。

基本的には、Maximaの一部として既に定義されている関数名や定数を再定義しようとしないことを推奨します。

## 不明確な置換、またはその他の置換

コード内で値の置換を行う際、その置換対象となる識別子が、後に関数名として使用されるものである場合、処理が複雑になる可能性があります。関数と変数には、同じ名前を使用しないようにしてください。
また、置換ルールを複雑な手順で生成すると、システムは安全のため、式に含まれるすべての変数が未知の値に書き換えられる可能性があるとみなして処理します。置換ルールの生成方法を単純化すれば、この判定を回避できます。

なお、4.4 でセキュリティシステムが変更された後、これらの問題はかなり稀になりました。新しいシステムではこれらのエラーを見ることはないはずです。

### 例 1

```maxima
v:1; /* particular case of rand([1,2]) */
trig:[sin,cos][v];
sub:[(sin(x))^2=1-(cos(x))^2,(cos(x))^2=1-(sin(x))^2][v];
f:(trig(x))^3;
df:diff(f,x);
df_simp:subst(sub,df);
```

これは以下のエラーメッセージを生成します。
> The function name "sin" is potentially redefined in unclear substitutions. The function name "diff" is potentially redefined in unclear substitutions.

ここでの問題は、`sub` が複雑な式であるため、検証システムがこのコードが何か疑わしいことをしていないと確認できないことです。

`subst` ではなく `ev` を使用してみる価値があるかもしれません。この例では、最後の行を以下のように変更すると、問題は再び動作します。

```maxima
df_simp:ev(df, sub);
```

### 例 2

```maxima
solution : rhs(ode2(eqn,y,x));
vars : delete(x,listofvars(solution));

TAns11 : subst([vars[1]=A,vars[2]=B],solution);
TAns12 : subst([vars[2]=A,vars[1]=B],solution);
```

ここでエラーメッセージは、`solution` に入るほぼ全ての要素が不明確な置換で再定義される可能性があると警告します。上記のコードが行っていることは、CAS で微分方程式を解き、その解で使用されている積分定数の名前を取得することです。方程式の形によっては定数が複数になることもありますが、この例では常に2つの定数（`%k1` と `%k2`）が存在します。もし定数が1つだけであれば、おそらく `%c` という名前になるでしょう。実際にどのような名前が使われるかを確認する必要があるのです。

この例であえて定数名を取得しているのには理由があります。それは、出題者が学生に対し、定数として A と B を使うよう強制したかったからです。さらに、定数の順序（どちらを A とし、どちらを B とするか）の選び方は2通りあるため、その両方に対応した正解を作成しています。ここで問題となるのは、定数の置換処理において、検証システムからは直接見えないリスト（vars）から名前を取得している点です（これが「不明瞭な置換」と判定されます）。これには2つの解決策があります。第一に、SubstEquiv テストを使用する方法です。このテストは任意の定数名の使用を許容するため、もし定数名の指定（AやBの使用）にこだわらず、単に正しい定数が使われていることさえ確認できればよいのであれば、この方法が有効です。ただし、その場合でも模範解答（Teacher's Answer）に `%k1` のようなCAS形式の定数がそのまま表示されてしまい、見た目が不自然になります。そのため、結局は見栄えを良くするために定数を置換する処理が必要になるでしょう。第二に、定数名をハードコーディング（直接記述）する方法です。今回のケースでは、生成される定数名は常に同じ（%k1 と %k2）であるため、以下のように直接記述しても問題にはなりません。

```maxima
solution : rhs(ode2(eqn,y,x));

TAns11 : subst([%k1=A,%k2=B],solution);
TAns12 : subst([%k2=A,%k1=B],solution);
```

## 学生の解答の利用

バージョン4.3以降、学生の解答が格納されている変数への書き込みは禁止されました。保存したい値がある場合は、単に他の有効な変数を使用してください。また、学生の入力を直接関数名として使用することも禁止されています。もしそのような処理が必要な場合は、ロジックを条件分岐に書き換える必要があります。あいにくですが、この制限は多肢選択問題（MCQ）の入力にも適用されます。

```maxima
/* このような書き方は禁止されています。 */
val: ans1(4);

/* 代わりに以下のように記述してください。 */
if is(ans1=sqrt) then
 val: sqrt(4)
else if(ans1=sin) then
 val: sin(4)
...

```

## 4.4 での `ev`

STACK 4.4 の新しいセキュリティモデルでは、実行順序が変更されたため、`ev` が Maxima の `ev` の挙動と完全には一致しなくなりました。ほとんどの用途では気づかない程度ですが、期待どおりに動作しない状況もあります。一般的に注意すべき状況は以下の通りです。

 1. `ev` の中に `expand` を置き、同じ `ev` 内で置換を行う場合：

 ```maxima
 /* これは置換の前に展開が行われる可能性があります */
 simp:false;
 tmp:ev(expand(x^3),x=x+1);

 /* 代わりに展開の前に置換を行ってください */
 tmp: ev(x^3,x=x+1);
 tmp: ev(expand(tmp));
 ```

 1. 一般に、ターゲットとなる式にセキュリティ検証を必要とする呼び出しが含まれている場合、置換が行われるのが遅すぎる可能性があります。

 これに対処するための推奨される方法は、`subst` または `at` を使用して置換を行い、評価に関連する修正は `ev` で別個に適用することです。

 1. `noeval` 評価フラグの使用は機能しない可能性があります。

 一般に、このフラグは STACK では役に立ちそうにありません。必要だと思われる場合は、名詞化（nounification）や同様のことを行う他の手段を検討してください。

場合によっては、単純に `eval` を追加のフラグとして `ev` 呼び出しに加えることが可能です。ただし、これが可能なのは、呼び出し内のすべての置換において、その左辺が右辺に含まれていない場合（自己参照的な置換でない場合）に限られます。

これらすべては評価フラグにも適用されることに注意してください。

```maxima
/* これらは等価です */
tmp: a+1,a=2;
tmp: ev(a+1,a=2);
```

## いくつかの推奨事項

特定の項目の検証プロセスでは、識別子の依存関係グラフが評価されます。そのため、これらのグラフを小さく保つことができれば、処理はより高速になる傾向があります。これを実現するためには、可能な限り同じ変数の再定義を避け、必要に応じて新しい変数を作成するようにしてください。つまり、すべての計算で `tmp` のような一時変数を使い回すことは避けてください。変数を使い回すと、その変数の依存関係グラフが非常に大きくなり、処理速度の低下を招く恐れがあります。少数の巨大なグラフよりも、多数の小さなグラフの方が処理は速くなります。また、グラフが巨大化すると、グラフ内のあるノードの特性が原因で、他のノードが特定の処理（例：関数識別子としての使用など）を行えなくなる可能性があります。

STACK翻訳
カスタム Gem
Gemini said
ご提示いただいた英文の翻訳案です。
STACKの内部処理（依存関係グラフの構築）に基づいた、パフォーマンス最適化のためのベストプラクティスを説明しています。

翻訳
特定の項目の検証プロセスでは、識別子の依存関係グラフ（dependency graphs）が評価されます。そのため、これらのグラフを小さく保つことができれば、処理はより高速になる傾向があります。

これを実現するためには、可能な限り同じ変数の再定義を避け、必要なときに新しい変数を作成するようにしてください。つまり、すべての計算で tmp のような一時変数を使い回すことは避けてください。変数を使い回すと、その変数の依存グラフが非常に大きくなり、処理速度の低下を招く恐れがあります。少数の巨大なグラフよりも、多数の小さなグラフの方が処理は速くなります。また、グラフが巨大化すると、グラフ内のあるノード（変数）の特性が原因で、他のノードが特定の処理（例：関数識別子としての使用など）を行えなくなる（ブロックされる）可能性があります。

同様に、問題内で複数の異なる「型」のオブジェクトに対して、同じ変数名を使い回すことも避けてください。例えば、`A` を行列として定義したならば、そのまま行列として扱ってください。リストや関数などに変更しないことで、保存時や、インポート/アップグレード後の初回実行時に行われる検証処理を高速化できます。

ローカルスコープ変数を定義するために `local()` を使用する場合は、常に `block` の最初（ただし、ブロック変数のリスト宣言を使用する場合は同じブロック内で `local()` を使用しないでください）、または `lambda` の先頭（引数の後）で呼び出してください。このように配置することで、依存グラフの構築ロジックがグラフの切れ目を特定し、スコープを正しく分離できるようになります。変数が使用された後に `local` を呼び出すとロジックを混乱させます。私たちはそのような特殊なケースへの対応を行う予定はありません。

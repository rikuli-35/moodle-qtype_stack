# 変数の定義

コンピュータ代数システム（Maxima）の変数を定義・操作できるフィールドは、「問題変数（Question Variables）」と「フィードバック変数（Feedback variables）」の2つだけである。

個々の代入は以下の形式をとる。

    key : value;

例えば：

    p : (x-1)^3;

それぞれの `key` はその問題にローカルな変数名、または関数名である。`value` は [Maxima](../../en/CAS/Maxima_background.md) 言語の式である。このリストは CAS に渡され、順番に評価される。それぞれの`key`に対して得られた値は保存され、後で（例：問題の採点時などに）使用される。`key`は一意である必要はないが、後で使用できるのは（同じキーに対して）最後に代入された値のみである。

これらのフィールドは _KeyVal_ フィールドとして知られている。

## Maxima における代入 `a:3`

Maxima、つまりSTACKは、変数に値を代入するために `key:value` という形式を使用する。これは独特で直感的ではないかもしれない。Maxima は関数定義（例：`f(x):=x^2`）を表すために `:=` を予約している。

## 注意

* 各項目は改行または `;` で区切られる。
* 各ステートメントの末尾に `;` を追加することは任意であるが、Maxima セッションへのコピー＆ペーストが容易になるため、追加することを推奨する。
* `key : value` の形式でない文字列を入力した場合、問題変数のリスト内でそのコマンドを追跡するために、`dumvar3` のような変数名が自動的に割り当てられる。
* `key` は単純な変数名でなければならない。文字で始まり、数字とアンダースコアを含むことができる。
* 問題変数で値が割り当てられている変数を学生が使用した場合、その解答は無効として却下される。「許可された単語（Allowed words）」を使用することで、問題変数を含む学生の式を有効とみなすことができる。
    したがって、問題のパラメータとして使用されていない変数名、または学生の解答で使用される可能性の低い変数名を使用するのが賢明である。例えば、積分の問題を作成する場合、変数 `c` の使用は避けるべきである。そうしないと、学生は積分定数を示すために `+c` と通常通りに記述できなくなる。
* 明確にするために C スタイルのブロックコメントを含めることができ、これらは別の行に記述することもできる。
    例：`dice : rand(6) + 1; /* サイコロを振る！ */`
* 入力（Input）と同じ名前のフィードバック変数を定義してはいけない。例えば、入力が `ans1` の場合、フィードバック変数 `ans1:exdowncase(ans1)` を定義することはできない。`ansmod1:exdowncase(ans1)` のように、別の名前を選ぶ必要がある。

## 問題変数 {#Question_variables}

問題変数は、問題のバリアントが作成されるときに評価される。表示形式は他のすべての [CASText](CASText.md) フィールドで利用可能であり、値は問題の他の部分で利用可能である。例：

* [input](../../en/Authoring/Inputs/index.md)における教師の解答（Teacher's answer）は、問題変数を使って定義される。
* [問題記録](../Authoring/Question_note.md)。
* 全体的なフィードバック（模範解答とも呼ばれる）。
* 各[ポテンシャル・レスポンス・ツリー](Potential_response_trees.md)内のすべてのフィールド。
* アイテムをテストする際の各入力。
* 学生が解答を検証（Validation）する際、特別な「コンテキスト変数」がプリアンブル（前文）で定義されていない限り、入力において問題変数は利用できない。

### 問題変数のプリアンブルとコンテキスト変数

以下のコマンドを問題変数内に表記した場合、それらは問題のすべての部分で利用可能になる。特に、これらのコマンドは学生の入力がどのように検証されるかに影響する。これにより、教師は学生の解答検証の表示に影響を与えたり、PRT（ポテンシャル・レスポンス・ツリー）に仮定を追加したりすることができる。

* `orderless` および `ordergreat`。これらのコマンドは、1つの問題につきそれぞれ1回しか使用できない。
* `assume` および `declare`。
* `texput`。直下の注記を参照できる。

これらの特別な変数は「コンテキスト変数」と呼ばれる。

STACK には特別な定数 `%_stack_preamble_end` がある。この定数より前にある変数はすべてコンテキスト変数に含まれる。これにより、例えば `texput` で使用する関数を定義することができる。

注意：学生は、教師が問題変数で定義したいかなる**変数名**も使用することは許可されていない。これにはコンテキスト変数と、通常の残りの問題変数の両方が含まれる。学生が使用できる変数を定義することはできない。ただし、学生はプリアンブルで定義された**関数名**は使用できる。例えば、プリアンブルに `vec(ex):=stackvector(ex);` と記述することが可能である。

使用例として、`assume(a>0)` とすることで、`AlgEquiv` 評価関数を使用して \(a\sqrt{5}=\sqrt{5a^2}\) を受け入れることができるようになる。通常は \(\sqrt{a^2}=|a|\neq a\) である。

例えば、`texput(blob, "\\diamond")` は単純である。関数を定義し、その関数を `texput` で使用することもできる。

    tuptex(z):= block([a,b], [a,b]:args(z), sconcat("\\left[",tex1(a),",",tex1(b),"\\right)"));
    texput(tup, tuptex); 
    %_stack_preamble_end;

無名の `lambda` 関数を使用することも可能である。例えば、関数 `tup` がある場合：

    texput(tup,  lambda([z], block([a,b], [a,b]:args(z), sconcat("\\left[",tex1(a),",",tex1(b),"\\right)")))); 

とすると、`tup(a,b)` は \( \left[a,b\right) \) と表示される。

関数 `hat` を作成し、入力 `hat(x)` が \(\hat{x}\) と表示されるようにするには、以下を使用できる：

    /* 問題変数内 */
    texput(hat, lambda([ex], sconcat("\\hat{", tex1(first(ex)), "}")));

より複雑な例として、`u(A_k,k,1,inf)` を \({\bigcup_{k = 1}^{\infty } {A}_{k}}\) とタイプセットするには、以下を使用できる：

    texput(u,lambda([ex],if length(ex)<4 then return("\\bigcup_{?=?}^{?} ? ") else
        sconcat("\\bigcup_{" ,tex1(second(ex)), " = ", tex1(third(ex)), "}^{", tex1(fourth(ex)), "} ", tex1(first(ex)))));

この例では、（不活性な）関数 `u` に与えられた引数の長さをチェックしていることに注目すること。必要な数の引数より少ない場合、この texput 関数は対応する出力を返す。この処理がないとエラーが発生し、学生にとっては不親切な設計になる。

別の例として、関数 `foo` を通常の分数として表示させることができる。

    texput(foo,lambda([e],[a,b]:args(e), sconcat("\\frac{", tex1(a), "}{", tex1(b), "}")));

TeX出力用のラムダ式が、単一の引数を受け取り、その後、関数内で（個々の要素に）分割されている点に注目すること。

## フィードバック変数 {#Feedback_variables}

フィードバック変数は、[ポテンシャル・レスポンス・ツリー](Potential_response_trees.md)における1つのフィールドを形成する。

[ポテンシャル・レスポンス・ツリー](Potential_response_trees.md)を使用する場合、[評価関数](../../en/Authoring/Answer_Tests/index.md)を適用する前に学生の解答を操作することがしばしば非常に有用である。これにより、高度な数学的操作を行う機会が得られる。

各評価関数が適用される前に、以下の変数リストが構築され、評価される。

1. 問題変数の値。
2. 各[inputs](../../en/Authoring/Inputs/index.md)の値。
3. フィードバック変数。

評価されたフィードバック変数の値は、評価関数やフィードバック内で使用できる。

注意：フィードバック変数のキーとして、入力の値を再定義することはできない。例えば、`ans1:ans1+1` のようなことはできない。新しい変数名を使用する必要がある。評価関数が評価される際、評価対象または評価基準のフィールドが入力の名前と正確に一致する場合、フィードバック変数の値ではなく、学生の生の入力値が使用される。これは、一部の評価関数が（CAS を介した値ではなく）タイプされた正確な内容（例：末尾のゼロ）を必要とするためである。この問題を回避するために、作成者は学生が実際に入力したものと計算された値を区別するために、新しい変数名を使用する必要がある。

## 変数名の作成

教師は Maxima の 'concat' コマンドを使用できないため、以下の形式のコードを使用して独自の変数名を作成することはできない。

    vars:makelist(concat(x,k),k,1,5);

代わりに以下を使用する：

    vars0:stack_var_makelist(k, 5);

0 ではなく 1 から番号付けを開始したい場合は、以下を使用する：

    vars1:rest(stack_var_makelist(k, 6));

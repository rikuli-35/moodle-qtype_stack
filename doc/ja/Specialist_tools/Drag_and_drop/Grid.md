# グリッド形式のドラッグ＆ドロップ問題

この構成では、`(columns, rows)` の形状のグリッドを設定する。学生はグリッド内の任意の位置にアイテムをドラッグ＆ドロップできる。

使用例：`[[parsons columns="3" rows="2"]] ... [[/parsons]]`

## トラブルシューティング

既知の問題とその解決方法については、[トラブルシューティング](Troubleshooting.md)のページを参照できる。

## 例：グリッドの問題例

この例では、関数とその導関数を適切な列と行にドラッグするように学生に求める。
この例は[グルーピングの例](Grouping.md)と同様にグルーピング形式でも作成できるが、重要な違いとして、グリッド形式ではグリッド内の任意の位置にアイテムをドラッグできるのに対し、グルーピング形式ではアイテムは列リストの末尾にのみ追加できる。

この例の大部分は[グルーピングの例](Grouping.md)と非常に似ているが、以下の重要な違いがある。

- `parsons` ブロックに `rows` パラメータを指定する必要がある。
- 正解フィールドの `match_answer` 関数では、第3パラメータに `true` を使用する。
- PRT内の `match_decode` 関数では、第3パラメータに `true` を使用する。
- また、ここでは行内の順序が保持されているかどうかにのみ関心があるため、PRTの評価関数の定義も多くの場合異なる。この違いは必須ではなく、システム上の要件から生じたものではない。この問題で何を評価したいか（すなわち、[グルーピングの例](Grouping.md)とは評価したい内容が異なる）という問題の性質に起因するものである。

### 問題変数

最低限、以下を含めることが推奨される。

- マッチングライブラリを読み込む。
- 利用可能アイテムリストのすべてのアイテムを、各アイテムが `["<ID>", "<実際のアイテムの内容>"]` の形式の配列からなる2次元配列として定義する。
`"<ID>"` 文字列は解答の記述や学生の入力の評価に使用し、2番目の項目は学生に表示される内容である。
- 利用可能アイテムをランダムに並べ替える。
- 解答列の上部に表示されるヘッダー。
- 正解を2次元配列として定義する。これは常に列ごとにグループ化されている必要がある。

この例では、_問題変数_フィールドは以下のようになる。

  stack_include_contrib("matchlib.mac");

  steps : [
    ["f", "\\(y = x^2\\)"],
    ["g", "\\(y = x^3\\)"],
    ["dfdx", "\\(y' = 2x\\)"],
    ["dgdx", "\\(y' = 3x^2\\)"],
    ["df2d2x", "\\(y'' = 2\\)"],
    ["dg2d2x", "\\(y'' = 6x\\)"]
  ];

  steps: random_permutation(steps);

  headers: [
    "Function",
    "\\(d/dx\\)",
    "\\(d^2/d^2x\\)"
  ];

  ta: [
    ["f", "g"],
    ["dfdx", "dgdx"],
    ["df2d2x", "dg2d2x"]
  ];

### 問題テキスト

ここでは以下を行う。

- 問題文を記述する。
- `input`、`columns`、`rows` のヘッダパラメータを指定して `parsons` ブロックを開く。
- `match_encode` を使用して、問題変数を `parsons` ブロック内のJSONに変換する。
- `parsons` ブロックを閉じる。

  <p>関数とその導関数を対応する列と行にドラッグしてください。</p>
  [[parsons input="ans1" columns="3" rows="2"]]
  {
      "steps" : {#match_encode(steps)#},
      "headers" : {#headers#}
  }
  [[/parsons]]
  <p>[[input:ans1]] [[validation:ans1]]</p>

### 問題記録

`steps` のランダム並べ替えがあるため、問題記録が必要である。以下を使用する。

{@map(first, steps)@}

### 解答欄：ans1

1. 解答形式フィールドは **Parsons** に設定する。
2. 正解フィールドは4要素のリストにする。以下のいずれかを使用する。

- `[ta, steps, headers, index]`：`parsons` ブロックで `headers` と `index` を指定した場合。
- `[ta, steps, headers, rows]`：`parsons` ブロックで `headers` のみ指定した場合。ここで `rows` は行数である（例：`[ta, steps, headers, 2]`）。
- `[ta, steps, cols, index]`：`parsons` ブロックで `index` のみ指定した場合。ここで `cols` は列数である（例：`[ta, steps, 2, index]`）。
- `[ta, steps, cols, rows]`：`parsons` ブロックで `headers` も `index` も指定しない場合。

1. 入力した解答の表示オプションを「いいえ」に設定する。
2. 数式の文法の確認オプションを「いいえ」に設定する。

手順3と4を設定することを強く推奨する。設定しない場合、学生に解答の内部状態を表すわかりにくいコードが表示されてしまう。

### ポテンシャル・レスポンス・ツリー：prt1

フィードバック変数を定義する。

  sans: match_decode(ans1, true);

これにより、学生の解答が `ans` と同じ形式の2次元配列として取得される。
この時点で、問題作成者は `sans` と `ans` を適切に比較して評価できる。この場合、行自体の順序は問題ではないが、行内の順序は重要である。そこで、`matchlib.mac` の `match_set_row` を使用して、フィードバック変数内で `sans` と `ans` の行リストを集合に変換する。

  sans: match_set_row(sans);
  tans: match_set_row(ta);

これにより、`sans` と `ans` の間で通常の代数的等価テストを実行できる。
ノードを `抑制：はい` に設定する。そうしないと、学生が不正解の場合にわかりにくいコードが表示されてしまう。

## 例：インデックス付きグリッドの問題例

最初のグリッドの例に左側のインデックスを追加するには、問題変数で `index` 配列を定義し、`parsons` ブロック内のJSONにこれを渡す。
これにより行の順序が固定され、評価が簡単になる。

重要なポイント：

- ヘッダーとインデックスの両方に該当するアイテムが必要である。このアイテムは、ヘッダーではなくインデックス内に含める必要がある。
- `parsons` ブロックの `columns` パラメータの値を1つ減らす。これは、このパラメータが解答列の数に対応するためである。
- `parsons` ブロック内のJSONで、`"index"` キーの値としてインデックスを渡す。

### 問題変数

インデックス付きの問題変数は以下の通りである。

  stack_include_contrib("matchlib.mac");

  steps : [
    ["dfdx", "\\(y' = 2x\\)"],
    ["dgdx", "\\(y' = 3x^2\\)"],
    ["df2d2x", "\\(y'' = 2\\)"],
    ["dg2d2x", "\\(y'' = 6x\\)"]
  ];

  steps: random_permutation(steps);

  headers: [
    "\\(d/dx\\)",
    "\\(d^2/d^2x\\)"
  ];

  index: [
    "Function",
    "\\(y = x^2\\)",
    "\\(y = x^3\\)"
  ];

  ta: [
    ["dfdx", "dgdx"],
    ["df2d2x", "dg2d2x"]
  ];

### 問題テキスト

  <p>関数とその導関数を対応する列と行にドラッグしてください。</p>
  [[parsons input="ans1" columns="2" rows="2"]]
  {
      "steps" : {#match_encode(steps)#},
      "headers" : {#headers#},
      "index" : {#index#}
  }
  [[/parsons]]
  <p>[[input:ans1]] [[validation:ans1]]</p>

### 問題記録

`steps` のランダム並べ替えがあるため、問題記録が必要である。以下を使用する。

  {@map(first, steps)@}

### 解答欄

前の例と全く同じである。

1. 解答形式フィールドは **Parsons** に設定する。
2. 正解フィールドは、教師の正解、すべてのステップ、列数、行数を含むリスト `[ta, steps, 2, 2]` にする。
3. 入力した解答の表示オプションを「いいえ」に設定する。
4. 数式の文法の確認オプションを「いいえ」に設定する。

### PRT

前の例と同様に、まず学生の入力から使用されたアイテムの2次元配列を取り出す。

  sans: match_decode(ans1, true);

この時点で、問題作成者は `sans` と `ta` を適切に比較して評価できる。
両方の次元の順序を固定しているので、正解は `ta` で与えられる1つだけである。したがって、`sans` と `ta` の間の代数的等価のみをテストする基本的なPRTとなる。ノードは必ず `抑制：はい` に設定する。そうしないと、学生が不正解の場合にわかりにくいコードが表示されてしまう。

# グルーピング形式のドラッグ＆ドロップ問題

この構成では、指定した数の列を設定する。各列は**証明問題**構成の左側の列と同様に動作し、学生は各列の先頭からアイテムをドラッグ＆ドロップできる。
この機能は、特定の行の位置は問わずアイテムをグループ化することのみを目的とする場合や、各列の長さ（配置するアイテム数）が異なる可能性がある場合に有用である。

使用例：`[[parsons columns="3"]] ... [[/parsons]]`

## トラブルシューティング

既知の問題とその解決方法については、[トラブルシューティング](Troubleshooting.md)のページを参照できる。

## 簡単な例

### 問題変数

    stack_include_contrib("matchlib.mac");

    steps: [
        ["f", "\\(y = x^2\\)"],
        ["g", "\\(y = x^3\\)"],
        ["quad", "Quadratic"],
        ["cubic", "Cubic"],
    ];

### 問題テキスト

    [[parsons columns="2"]]
    {# match_encode(steps) #}
    [[/parsons]]

## クローンモード

ブロックヘッダで `clone="true"` を設定すると（`[[parsons columns="n" clone="true"]][[/parsons]]` のように）、アイテムを再利用できることを明示できる。グルーピングやグリッド形式でこの機能がよく利用される。

## 読み込み時の転置

学生は縦方向と横方向の表示を自由に切り替えることができるが、読み込み時のデフォルトは列が縦方向に表示される。ヘッダで `transpose="true"` を設定すると（`[[parsons columns="n" transpose="true"]][[/parsons]]` のように）、読み込み時に横方向表示がデフォルトで表示されるようになる。

## ヘッダー

デフォルトでは、グルーピングおよびグリッドレイアウトの解答リストには、正の整数でインデックスされたヘッダーが付く。利用可能アイテムリストのデフォルトヘッダーは「ここからドラッグする:」である。これらは**行グルーピング**レイアウトや、ユーザーが方向切り替えボタンを押した際に行インデックスになる。

解答リストのヘッダーは、`"headers"` キーに新しいヘッダーの文字列配列を割り当てることで変更できる。利用可能アイテムリストのヘッダーは、`"available_header"` キーに文字列を割り当てることで変更できる。

### 問題変数

    stack_include_contrib("matchlib.mac");

    steps: [
        ["f", "\\(y = x^2\\)"],
        ["g", "\\(y = x^3\\)"],
        ["quad", "Quadratic"],
        ["cubic", "Cubic"],
    ]

### 問題テキスト

    [[parsons columns="2"]]
    {
        "steps" : {# match_encode(steps) #},
        "headers" : ["Equation", "Type"],
        "available_header" : "Available items"
    }
    [[/parsons]]

`headers` は列数と同じ長さのリストでなければならず、`available_header` は文字列でなければならないことに注意する。
列が多い場合、長いヘッダーはボックスからはみ出す可能性があるため、できるだけ短くすることが推奨される。

## インデックス

デフォルトでは、**列グルーピング**および**グリッド**レイアウトではインデックスは使用されない。**行グルーピング**モードではヘッダーがインデックスとなり、この場合デフォルトではヘッダーは存在しない。

これを変更するには、以下のようにJSONにインデックスを渡す。

    [[parsons columns="1" rows="2"]]
    {
        "steps": {# match_encode(steps) #},
        "headers" : ["Type"]
        "available_header" : "Available items"
        "index" : ["Equation", "\\(y = x^2\\)", "\\(y = x^3\\)"]
    }
    [[/parsons]]

インデックスの長さは `rows + 1` と同じでなければならない。インデックスのヘッダーが不要な場合は、最初の位置に空文字列を渡すことができる。

## 例：グルーピングの問題例

最初の例では、方程式で定義された関数を「微分可能」「連続だが微分不可能」「不連続」のカテゴリに分類するように学生に求める。

### 問題変数

最低限、以下を含めることが推奨される。

- マッチングライブラリを読み込む。
- 利用可能アイテムリストのすべてのアイテムを、`["<ID>", "<実際のアイテムの内容>"]` の形式の配列からなる2次元配列として定義する。
`"<ID>"` 文字列は解答の記述や学生の入力の評価に使用し、2番目の項目は学生に表示される内容である。
- 利用可能アイテムをランダムに並べ替える。
- 解答列の上部にヘッダーを表示する。
- 正解を2次元配列として定義する。これは列ごとにグループ化されている必要がある。

この例では、問題変数フィールドは以下のようになる。

    stack_include_contrib("matchlib.mac");

    steps : [
        ["sq", "\\(f(x) = x^2\\)"],
        ["sin", "\\(f(x) = \\sin(x)\\)"],
        ["abs", "\\(f(x) = |x|\\)"],
        ["sqrt", "\\(f(x) = \\sqrt{|x|}\\)"],
        ["rec", "\\(f(x) = \\left\\{\\begin{array}{ll}1/x &, x\\neq 0 \\\\ 0&, x=0\\end{array}\\right.\\)"],
        ["sgn", "\\(f(x) = \\text{sgn}(x)\\)"]
    ];

    steps: random_permutation(steps);

    headers: [
        "Differentiable", 
        "Continuous, not differentiable", 
        "Discontinuous"
    ];

    ta: [
        ["sq", "sin"], 
        ["abs", "sqrt"], 
        ["rec", "sgn"]
    ];

### 問題テキスト

ここでは以下を行う。

- 問題文を記述する。
- `input` と `columns` のヘッダパラメータを指定して `parsons` ブロックを開く。
- `match_encode` を使用して、問題変数を `parsons` ブロック内のJSONに変換する。
- `parsons` ブロックを閉じる。

    <p>関数は微分可能、連続だが微分不可能、または不連続のいずれかです。以下の式はそれぞれ関数 \(f:\mathbb{R}\rightarrow\mathbb{R}\) を定義しています。
    各関数を適切なカテゴリにドラッグしてください。</p>
    [[parsons input="ans1" columns="3"]]
    {
        "steps" : {#match_encode(steps)#},
        "headers" : {#headers#}
    }
    [[/parsons]]
    <p>[[input:ans1]] [[validation:ans1]]</p>

### 問題記録

`steps` のランダム並べ替えがあるため、問題記録が必要である。以下を使用する。

    {@map(first, steps)@}

### 解答欄：ans1

1. 解答形式フィールドは **Parsons** に設定する。
2. 正解フィールドは3要素のリストにする。`headers` パラメータを指定している場合は `[ta, steps, headers]` を使用する（`ta` は教師の正解、`steps` はすべてのステップのキーと文字列のペアを含む配列）。指定していない場合は `[ta, steps, cols]` を使用する（`cols` は列数、例：`[ta, steps, 3]`）。
3. 入力した解答の表示オプションを「いいえ」に設定する。
4. 数式の文法の確認オプションを「いいえ」に設定する。

手順3と4を設定することを強く推奨する。設定しない場合、学生に解答の内部状態を表すわかりにくいコードが表示されてしまう。

### ポテンシャル・レスポンス・ツリー：prt1

フィードバック変数を定義する。

    sans: match_decode(ans1);

これにより、学生の解答が `ans` と同じ形式の2次元配列として取得される。この時点で、問題作成者は `sans` と `ans` を適宜比較して評価できる。この場合、列内の順序は問題ではないが、列自体の順序は重要である。そこで、`matchlib.mac` の `match_column_set` を使用して、フィードバック変数内で `sans` と `ans` の各列を集合に変換する。

    sans: match_column_set(sans);
    tans: match_column_set(ta);

これにより、`sans` と `ans` の間で通常の代数的等価テストを実行できる。ノードを `抑制：はい` に設定する。そうしないと、学生が不正解の場合にわかりにくいコードが表示されてしまう。

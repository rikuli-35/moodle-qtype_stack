# グリッド形式のドラッグ＆ドロップ問題

この構成では、`(columns, rows)` の形状のグリッドを設定します。学生はグリッド内の任意の位置にアイテムをドラッグ＆ドロップできます。

使用例：`[[parsons columns="3" rows="2"]] ... [[/parsons]]`

## トラブルシューティング

既知の問題とその解決方法については、[トラブルシューティング](Troubleshooting.md)のページを参照してください。

## 例：グリッドの問題例

この例では、関数とその導関数を適切な列と行にドラッグするように学生に求めます。
この例は[グルーピングの例](Grouping.md)と同様にグルーピング形式でも作成できますが、重要な違いとして、グリッド形式ではグリッド内の任意の位置にアイテムをドラッグできるのに対し、グルーピング形式ではアイテムは列リストの末尾にのみ追加できます。

この例の大部分は[グルーピングの例](Grouping.md)と非常に似ていますが、以下の重要な違いがあります。

- `parsons` ブロックに `rows` パラメータを指定する必要があります。
- 正解フィールドの `match_answer` 関数では、第3パラメータに `true` を使用します。
- PRT内の `match_decode` 関数では、第3パラメータに `true` を使用します。
- また、ここでは行内の順序が保持されているかどうかにのみ関心があるため、PRTの評価関数の定義も多くの場合異なります。この違いは必須ではなく、システム上の要件から生じたものではありません。この問題で何を評価したいか（すなわち、[グルーピングの例](Grouping.md)とは評価したい内容が異なる）という問題の性質に起因するものです。

### 問題変数

最低限、以下を含めることが推奨されます。

- マッチングライブラリを読み込む。
- 利用可能アイテムリストのすべてのアイテムを、各アイテムが `["<ID>", "<実際のアイテムの内容>"]` の形式の配列からなる2次元配列として定義する。
`"<ID>"` 文字列は解答の記述や学生の入力の評価に使用し、2番目の項目は学生に表示される内容です。
- 利用可能アイテムをランダムに並べ替える。
- 解答列の上部に表示されるヘッダー。
- 正解を2次元配列として定義する。これは常に列ごとにグループ化されている必要があります。

この例では、_問題変数_フィールドは以下のようになります。

  stack_include_contrib("matchlib.mac");

  steps : [
    ["f", "\\(y = x^2\\)"],
    ["g", "\\(y = x^3\\)"],
    ["dfdx", "\\(y' = 2x\\)"],
    ["dgdx", "\\(y' = 3x^2\\)"],
    ["df2d2x", "\\(y'' = 2\\)"],
    ["dg2d2x", "\\(y'' = 6x\\)"]
  ];

  steps: random_permutation(steps);

  headers: [
    "Function",
    "\\(d/dx\\)",
    "\\(d^2/d^2x\\)"
  ];

  ta: [
    ["f", "g"],
    ["dfdx", "dgdx"],
    ["df2d2x", "dg2d2x"]
  ];

### 問題テキスト

ここでは以下を行います。

- 問題文を記述する。
- `input`、`columns`、`rows` のヘッダパラメータを指定して `parsons` ブロックを開く。
- `match_encode` を使用して、問題変数を `parsons` ブロック内のJSONに変換する。
- `parsons` ブロックを閉じる。

  <p>関数とその導関数を対応する列と行にドラッグしてください。</p>
  [[parsons input="ans1" columns="3" rows="2"]]
  {
      "steps" : {#match_encode(steps)#},
      "headers" : {#headers#}
  }
  [[/parsons]]
  <p>[[input:ans1]] [[validation:ans1]]</p>

### 問題記録

`steps` のランダム並べ替えがあるため、問題記録が必要です。以下を使用します。

{@map(first, steps)@}

### 解答欄：ans1

1. 解答形式フィールドは **Parsons** に設定します。
2. 正解フィールドは4要素のリストにします。以下のいずれかを使用します。

- `[ta, steps, headers, index]`：`parsons` ブロックで `headers` と `index` を指定した場合。
- `[ta, steps, headers, rows]`：`parsons` ブロックで `headers` のみ指定した場合。ここで `rows` は行数です（例：`[ta, steps, headers, 2]`）。
- `[ta, steps, cols, index]`：`parsons` ブロックで `index` のみ指定した場合。ここで `cols` は列数です（例：`[ta, steps, 2, index]`）。
- `[ta, steps, cols, rows]`：`parsons` ブロックで `headers` も `index` も指定しない場合。

1. 入力した解答の表示オプションを「いいえ」に設定します。
2. 数式の文法の確認オプションを「いいえ」に設定します。

手順3と4を設定することを強くお勧めします。設定しない場合、学生に解答の内部状態を表すわかりにくいコードが表示されてしまいます。

### ポテンシャル・レスポンス・ツリー：prt1

フィードバック変数を定義します。

  sans: match_decode(ans1, true);

これにより、学生の解答が `ans` と同じ形式の2次元配列として取得されます。
この時点で、問題作成者は `sans` と `ans` を適切に比較して評価できます。この場合、行自体の順序は問題ではありませんが、行内の順序は重要です。そこで、`matchlib.mac` の `match_set_row` を使用して、フィードバック変数内で `sans` と `ans` の行リストを集合に変換します。

  sans: match_set_row(sans);
  tans: match_set_row(ta);

これにより、`sans` と `ans` の間で通常の代数的等価テストを実行できます。
ノードを `抑制：はい` に設定してください。そうしないと、学生が不正解の場合にわかりにくいコードが表示されてしまいます。

## 例：インデックス付きグリッドの問題例

最初のグリッドの例に左側のインデックスを追加するには、問題変数で `index` 配列を定義し、`parsons` ブロック内のJSONにこれを渡します。
これにより行の順序が固定され、評価が簡単になります。

重要なポイント：

- ヘッダーとインデックスの両方に該当するアイテムが必要です。このアイテムは、ヘッダーではなくインデックス内に含める必要があります。
- `parsons` ブロックの `columns` パラメータの値を1つ減らしてください。これは、このパラメータが解答列の数に対応するためです。
- `parsons` ブロック内のJSONで、`"index"` キーの値としてインデックスを渡します。

### 問題変数

インデックス付きの問題変数は以下の通りです。

  stack_include_contrib("matchlib.mac");

  steps : [
    ["dfdx", "\\(y' = 2x\\)"],
    ["dgdx", "\\(y' = 3x^2\\)"],
    ["df2d2x", "\\(y'' = 2\\)"],
    ["dg2d2x", "\\(y'' = 6x\\)"]
  ];

  steps: random_permutation(steps);

  headers: [
    "\\(d/dx\\)",
    "\\(d^2/d^2x\\)"
  ];

  index: [
    "Function",
    "\\(y = x^2\\)",
    "\\(y = x^3\\)"
  ];

  ta: [
    ["dfdx", "dgdx"],
    ["df2d2x", "dg2d2x"]
  ];

### 問題テキスト

  <p>関数とその導関数を対応する列と行にドラッグしてください。</p>
  [[parsons input="ans1" columns="2" rows="2"]]
  {
      "steps" : {#match_encode(steps)#},
      "headers" : {#headers#},
      "index" : {#index#}
  }
  [[/parsons]]
  <p>[[input:ans1]] [[validation:ans1]]</p>

### 問題記録

`steps` のランダム並べ替えがあるため、問題記録が必要です。以下を使用します。

  {@map(first, steps)@}

### 解答欄

前の例と全く同じです。

1. 解答形式フィールドは **Parsons** に設定します。
2. 正解フィールドは、教師の正解、すべてのステップ、列数、行数を含むリスト `[ta, steps, 2, 2]` にします。
3. 入力した解答の表示オプションを「いいえ」に設定します。
4. 数式の文法の確認オプションを「いいえ」に設定します。

### PRT

前の例と同様に、まず学生の入力から使用されたアイテムの2次元配列を取り出します。

  sans: match_decode(ans1, true);

この時点で、問題作成者は `sans` と `ta` を適切に比較して評価できます。
両方の次元の順序を固定しているので、正解は `ta` で与えられる1つだけです。したがって、`sans` と `ta` の間の代数的等価のみをテストする基本的なPRTとなります。ノードは必ず `抑制：はい` に設定してください。そうしないと、学生が不正解の場合にわかりにくいコードが表示されてしまいます。

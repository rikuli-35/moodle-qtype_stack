# 同値変形入力の評価

これは[同値変形入力](Equivalence_input.md)の解答を評価するためのリファレンスドキュメントです。

## 評価関数

学生が入力した式のリストがすべて同値であるかどうかを判定するための評価関数がいくつか用意されています。

これらの評価関数には「ステップサイズ」の概念はなく、学生が合理的な順序で作業しているかどうかのテストもありません。
評価関数は解答形式とコードを共有しており、表示される場合、テストからのフィードバックは解答形式のフィードバックと同一です。

解答形式と同様に、評価関数にオプションを反映させるためには、適切なオプションを設定する必要があります。
サポートされているオプションは `assume_pos`、`assume_real`、`calculus` です。

### EquivReasoning

このテストは、リスト内のすべての項目が代数的同値性を用いて同値であることを判定します。

### EquivFirst

1. このテストは、リスト内のすべての項目が代数的同値性を用いて同値であることを判定します。
2. 学生の解答の最初の行が教師の解答の最初の行と、可換性と結合性に基づいて同値であるかをテストします（EqualComAss 評価関数を使用）。

論証の最後の行が正しい形式であるかをテストするには、ポテンシャル・レスポンス・ツリーに別のノードが必要です。評価関数にこれを組み込むと、可能性が多くなりすぎてしまいます。

## 自然な定義域

同値変形入力は式の自然な定義域を追跡します。これはSTACKの `natural_domain(ex)` 関数を通じて行われます。自然な定義域はバリデーションフィードバック内で学生に表示されます。
\\[ \\begin{array}{lll} &\\frac{5\\,x}{2\\,x+1}-\\frac{3}{x+1}=1&{\\color{blue}{{x \\not\\in {\\left \\{-1 , -\\frac{1}{2} \\right \\}}}}}\\cr \\color{green}{\\Leftrightarrow}&5\\,x\\,\\left(x+1\\right)-3\\,\\left(2\\,x+1\\right)=\\left(x+1\\right)\\,\\left(2\\,x+1\\right)& \\end{array} \\]
現時点では、STACKは上記の例のような暗黙の定義域の拡大を黙認しています。

## 重根

根の重複度をどのように表現するかについては、一般的に曖昧さがあります。\\((x-1)^2=0\\) が \\(x=1\\) と同値でないとすれば、学生は根の重複度を示す必要がありますが、これをどのように記法化すべきかについてのコンセンサスは存在しません。

方程式 \\( (x-3)^2 = 0 \\) と式 \\( x=3 \\text{ or } x=3\\) は、同じ根を同じ重複度で持つため、同値と見なされます。
式 \\( x=3 \\text{ or } x=3\\) と \\( x=3\\) は同じ解集合を定めますが、同一ではありません。
これは当然やや問題をはらんでいます。なぜなら、論理演算子 ``or'' はべき等であるため、\\( x=3 \\text{ or } x=3\\) と \\( x=3\\) は記号レベルでは同値となるはずだからです。
このため、STACKは \\(x=3\\) を \\((x-3)^2=0\\) と同値として受け入れますが、注記を伴います。
\\[ \\begin{array}{lll} &\\left(x-3\\right)^3=0& \\cr \\color{green}{\\text{(Same roots)}}&x=3& \\cr \\end{array} \\]

## その他の関数

Maxima関数 `stack_disp_arg(ex, [showlogic, showdomain])` を使用すると、式のリスト `ex` を、解答形式や評価関数で使用されるのと同じ形式で表示できます。これは全般的なフィードバックで教師の模範解答を表示する際に便利です。

2番目以降の引数はオプションです。

1. ブール変数 `showlogic` は、同値記号を表示するかどうかを決定します。
2. ブール変数 `showdomain` は、自然な定義域を表示するかどうかを決定します。

模範解答を表示する際は以下の関数を使用します。

    \[ {@stack_disp_arg(ta)@} \]

同値記号なしで表示する場合は以下を使用します。

    \[ {@stack_disp_arg(ta, false)@} \]

同値記号は表示するが自然な定義域は表示しない場合は以下を使用します。

    \[ {@stack_disp_arg(ta, true, false)@} \]

## 計算過程における特定ステップの検索

学生に論証の中で「特定のステップ」を踏ませたいということはよくあります。つまり、学生の解答リストの中に特定の中間式が明示的に含まれていることを期待する場合です。

例えば、学生に \\( \\log_5(25) \\) を \\(2\\) に「簡約」させたい場合を考えます。その際、解答の中に式 \\( \\log_5(5^2) \\) が含まれているという証拠が重要です。教師の解答は、例えば以下のようになります。

    ta:[lg(25,5),stackeq(lg(5^2,5)),stackeq(2*lg(5,5)),stackeq(2*1),stackeq(2)]

以下の解答は受け入れたいとします。

    sa1:[lg(25,5),stackeq(lg(5^2,5)),stackeq(2)]

しかし、以下の解答は拒否したいとします。

    sa0:[lg(25,5),stackeq(2)]

これらはどちらも正しい推論ですが、後者には要求したいステップが欠けています。

この検索を容易にするために、関数 `stack_equiv_find_step(ex, exl)` を提供しています。この関数は、`ATEqualComAss` を使用して式 `ex` をリスト `exl` の中から検索し、一致した位置のインデックスのリストを返します。式が含まれていないかどうかだけを知りたい場合は、述語関数 `emptyp` を使用してください。なお、この関数はテスト前に `stackeq` を取り除くため、以下の `sa2` でも `sa1` でも \\( \\log_5(5^2) \\) を発見します。

    sa2:[lg(25,5),lg(5^2,5),2]

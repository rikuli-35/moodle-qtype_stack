# 同値変形入力

これは同値変形入力のリファレンスドキュメントです。

## 同値変形とは

この解答形式は、学生の行ごとの推論を取得し、評価することを可能にします。

## 学生はこの解答形式をどのように使用するか

従来の演習において、学生は方程式が解けるまで行ごとに式を書き換えながら計算を進めます。この解答形式は、各行が前の行と同値であるべきという前提に基づいて、このような計算過程を取得し評価するために設計されています。

STACKには[学生向けの説明](../../Students/Equivalence_reasoning.md)があります。また、この形式の推論に関して以下の傾向が良く見られます。

1. 学生は行間に論理接続詞を使用しないことが多い。
2. 学生は式の自然な定義域を無視する。例えば \\(\\frac{1}{x}\\) では \\(x=0\\) は定義域から除外されるにも関わらず、それを無視する。
3. 同値性を保たない操作（例えば方程式の両辺を二乗する操作）がしばしば使用される。

この入力タイプは、現在の一般的な学習慣行をそのまま反映しており、学生に対して論理結合子や定義域を明記することは求めていません。その代わり、解答形式自体がこれらの問題に関するフィードバックを学生に提供します。

なお、学生は命題論理の接続詞 `or` と `and` を正しく使用しなければなりません。
例えば、解答は `x=1 or x=2` のような正しい形式でなければならず、`x=1 or 2` や `x=1,2` のような厳密さを欠く表記は認められません。
`x=1 and x=2` のような、筆記の解答ではよく見られますが数学的に誤った記述も認められません。

なお、学生は方程式の両辺の平方根をとることはできません。これは同値ではないため、拒否されます。同様に、ゼロになる可能性がある項を両辺から消去することもできません。同値性を要求しているため、学生は両辺にゼロになる可能性がある項を掛け算することも許されません。これはおそらく学生の期待とは合致せず、慣れるまでに少し時間がかかるかもしれません。

ところで、学生は本当に論理接続詞を使うべきなのでしょうか？ 著者（CJS）はそうすべきだと考えていますが、現時点で解答形式からそれを要求するのは、学生と教師にとって高すぎるハードルになるでしょう。現状でも学生はすでに `and` や `or` などの接続詞を正しく使うことが求められています。この解答形式はこれらの結合子を使用しており、将来的には学生に論理結合子の明示を要求するオプションが追加される可能性があります。特に、同値性に加えて含意のサポートを追加する場合にはそうなるでしょう。同値変形を用いた教育のノウハウが蓄積されるにつれて、この解答形式にさらなるオプションを追加していく予定です。

## 数式の検証と正誤判定

STACKは、学生の解答の検証と正誤判定を注意深く分離しています。
この考え方は、解答欄に紐付けられた `[[validation]]` タグによる検証フィードバックと、数学的特性を判定するポテンシャル・レスポンス・ツリーの分離によって具現化されています。

学生の解答の各行は、代数式入力タイプと同様に、有効な式でなければなりません。
ただし、この解答形式では集合、リスト、行列は許可されていません。
内部的な結果は式（方程式または不等式）の**リスト**となります。

### 数式の検証

検証では通常、即座にフィードバックが提供されます。これらの記号については[同値変形の数学](Equivalence_reasoning.md)ページに記載されています。

## この解答形式のユースケース

1. 同値変形が課題のすべてである場合。論証が正しく、最後の行が最終解答でなければなりません。
2. 形成的評価の場面で、論証が同値な行で構成されているかどうかについて即時フィードバックを提供したい場合。このフィードバックは以下のいずれかのタイミングで提供できます。
   1. 学生が一行ずつ入力するたびに提供する。
   2. 学生が「チェック」を押した時点でまとめて提供する。

隣接する行の同値性について学生の入力中にフィードバックを提供する機能は、数式の検証と正誤判定の区別をやや曖昧にしますが、学生にとっては非常に有用な形であると考えられます。

## 問題作成者向けの注意事項

* 数式の検証タグ（例：`[[validation:ans1]]`）の配置はこの解答形式では無視されます。数式の検証フィードバックは常に、学生が解答を入力するテキストエリアの隣に表示されます。
* 教師の解答と書式のヒントはリストでなければなりません。単独の式を渡すと、予期しない動作が生じる可能性があります。
* この解答形式はテキストエリア入力タイプと非常によく似た動作をします。内部的には、学生の各行がリストに変換されます。解答の最終行を使用したい場合は、ポテンシャル・レスポンス・ツリーで `last(ans1)` のコードを使用してください。
* 学生が方程式ではなく式を入力した場合、システムは学生が末尾に \\(=0\\) を付け忘れたものと見なし、それに応じた処理を行います。この旨は学生に表示されます。

学生が行頭を `=` 記号で始めた場合、それは受け入れられます。ただし、教師は接頭辞として `=` を使用できません。模範解答を作成する際、教師は代わりに接頭辞関数 `stackeq` を使用しなければなりません。例：

    ta:[(x-1)^2,stackeq(x^2-2*x+1)]

教師は `and` や `or` の論理演算子ではなく、`nounand` と `nounor` コマンドを明示的に使用しなければなりません。詳細は[簡略化](../../CAS/Simplification.md)のセクションを参照してください。例えば、模範解答は以下のようになります。

    ta:[p=0,(v-n1)*(v-n2)=0,v-n1=0 nounor v-n2=0,v=n1 nounor v=n2]

## 書式のヒント

書式のヒントのCASTextを評価した結果はリストでなければなりません。これはMaximaによって再解釈されるため、単独の式を渡すと予期しない動作が生じる可能性があります。

CASTextを使用して書式のヒントを微調整できます。特に、最初の行から `*` を除去したい場合、これはMaximaの式レベルではなく**表示**レベルで作業するのが最適な（珍しい）状況です。通常、特にPRTでは、数学的意味を確立するためにMaximaレベルで作業するのが最善です。しかし、ここでは式の表示方法を微調整する必要があります。式のきれいな文字列表現を作成するためのオプションが現在2つあります。

1. `sh:stack_disp(unary_minus_sort(p), "")` は（STACK用に微調整された）LaTeX形式の出力が得られます。ただし、LaTeXの数式環境外であるこの場所でこの形式を用いる場合の問題点として、(i) `\left(...\right)` がそのまま使用されてしまうこと、(ii) 割り算に `\frac{}{}` が使用されてしまうことなどが挙げられます。
2. `sh:sremove("*", string(unary_minus_sort(p)))` は文字列出力を提供します。この形式の問題点としては、(i) 括弧が過剰になること、(ii) `nounand` などの名詞形式が変換されないことなどがあります。また、このMaxima関数はSTACKによって微調整されていません。

この問題を一般的に解決するための未着手の開発タスクとして、Maximaの `tex` コマンドのような出力フォーマット関数の作成があります。ただし、これには多大な作業量が必要です。

以下は、単項マイナスの問題を解決する問題変数の具体例です。

    p:-8*a*d-3*b*c+6*a*c+4*b*d;
    make_multsgn("space");
    sh:stack_disp([unary_minus_sort(p)],"");
    ta:[p,ev(p,simp)];

この設定を行った上で、書式のヒントに `[{@sh@}]` を使用します。

## 解答形式のオプション

この解答形式のオプションを入力するには、「その他のオプション」フィールドを使用してください。オプションは、以下のリストの値のみを使用し、コンマ区切りのリストで指定します。

`hideequiv` は、数式の検証時に各行が次の行と同値であるかどうかの表示を行わないようにします。

`hidedomain` は、自然な定義域の情報を表示しないようにします。

`comments` は、学生が解答にコメントを含めることを許可します。デフォルトではコメントは許可されていません。コメントは論証を分断し、自動採点を妨げるためです。

`firstline` は、教師の解答の最初の行を取得し、学生の解答の最初の行がそれと一致することを強制します。使用されるテストは可換性と結合性に基づく等価性判定（"代数等価"評価関数）です。

`assume_pos` は、Maximaの `assume_pos` 変数の値を `true` に設定します。
`assume_pos` を設定すると、負の解は存在するかどうかに関わらず無視されます。したがって、\\(x=\\pm 2\\) は \\(x=2\\) と同値になります。
この同値性が望ましくない場合があるかもしれません。特に、このオプションは方程式の両辺を二乗したり平方根をとったりする操作を事実上容認する効果もあります。
例えば、\\(x^4=2\\) は \\(x=2\\)（\\(x=2 \\vee x=-2\\) ではなく）と同値になります。
これはデフォルトではありませんが、すべての変数が正であると仮定して学生が方程式を特定の主語に変形する場面で有用です。なお、このオプションは解答形式にのみ適用されます。評価関数にも影響させるには、問題オプションでもこの設定を行う必要があります。

`assume_real` は、実数上で作業するための内部フラグを設定します。`true` に設定すると、\\(x=1\\) は \\(x^3=1\\) と同値と見なされます。なお、このオプションは解答形式にのみ適用されます。評価関数にも影響させるには、問題オプションでもこの設定を行う必要があります。

`calculus` は、論証内での微積分操作を許可します。なお、このオプションは解答形式にのみ適用されます。評価関数にも影響させるには、評価関数のオプションでもこの設定を行う必要があります。この機能は開発の非常に初期段階にあります。
例えば、積分定数のチェックは現時点ではサポートされていません。

書式ヒントに `firstline` というキーワードのみを指定した場合、教師の解答の値の1行目が構文ヒントとして表示されます。これにより、ランダムに生成した構文ヒントを解答ボックスに表示することが可能になります。

### 「let」

学生は `let v=a` と入力することで、変数に値を代入できます。この値はその後のすべての計算で使用されます。

例えば、同値変形入力で以下を試してみてください。

    x^2=a^2
    let a=2
    (x-2)*(x+2)=0

内部的には `stacklet(v,a)` という特殊関数が使用され、同値変形内で変数 `v` に値 `a` を持たせることを示します。なお、これは変数への値の代入のみを行うものであり、設計上、関数の定義には対応していません。

学生の解答（例えば `ans1` など）に含まれるすべての代入操作を抽出するには、フィードバック変数（feedback variables）内で `stacklet` 関数をフィルタリングします。注意: このとき学生の解答はリスト形式で扱われます。

    L1:sublist(ans1,lambda([ex],safe_op(ex)="stacklet"));

これにより、`L1` は代入操作のリストになります。これを方程式のリストに変換したい場合は、以下のようにします。

    L1:ev(L1,stacklet="=");

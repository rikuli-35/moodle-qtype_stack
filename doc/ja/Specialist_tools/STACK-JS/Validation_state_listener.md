# バリデーション状態リスナーと追加バリデーションメッセージ

このページでは、STACKライブラリの例題 *Doc-Examples > Specialist-Tools > STACK-JS > Validation state listener* について解説する。この例題は、それほど効率的ではない方法で組み合わせた高度な機能のデモンストレーションである。意図的に作成された注意喚起の例であり、基本的には正しく動作する。

## 例題の特徴

この例題では、JSXGraphを使用して (x,y) 座標のリストを曲線としてプロットする。つまり、関数を描画する。ただし、通常とは異なる点として、インスタントバリデーションに応じてプロットを行えるように、これらの座標をカスタムのバリデーションフィードバック内で生成している点である。新しいフィードバックを検知してグラフの更新を発火させるために、バリデーション状態リスナー（validation state listener）が使用されている。

### カスタムバリデーション

解答欄には、カスタムバリデーションテスト（解答の有効性に関する検証テスト）と応答メッセージを設定できる。これらのいわゆる[カスタムバリデータ](../../../en/CAS/Validator.md)は、受け取った入力に対して動作し、学生に表示される出力を生成できる。この例題では、問題にバリデータとフィードバックジェネレータの両方が含まれている。バリデータは、入力がxの関数であり、それ以外のものでないことを検証する（プロットが可能であるかを確認するため）。フィードバックジェネレータは、あらかじめ決められた範囲内の200点で入力を評価し、それらの点をJSON形式でエンコードした隠し `<div>` を出力する。

バリデータとフィードバックジェネレータの両方は問題変数で定義され、解答欄のその他のオプションを通じて解答欄に紐付けられる。なお、生成されるフィードバックは名前付きの `<div>` を使用しており、その名前は [`[[quid]]`](../../Authoring/Question_blocks/Static_blocks.md#quid-question-unique-identifier-block) ブロックを使用して問題の使用レベルで一意にされていることに注意する。これは、ロジック内で名前付きの要素を参照する際に推奨される手法である。

この問題の主な課題はフィードバックジェネレータに関連している。200点分のデータは応答メッセージ内で容量を占め、即時と見なせないほど応答を遅くする可能性がある。さらに、その関数がそれらの点で実際に評価可能かどうかを確認するための、合理的な実行時間内で動作するバリデータは存在しない。

### JSXGraph内でのSTACK-JS

この問題では、[JSXGraph](../JSXGraph/index.md)を使用してプロットを行うが、このケースではJSXGraphを解答欄に接続しない。そのため、通常使用する入力参照やバインディング関数は使用しない。代わりに、バリデーション状態リスナー（`stack_js.register_validation_state_listener`）を使用し、バリデーションのさまざまな状態に応じて異なる処理を行う。

 1. バリデーションの開始時には、通常のバリデーション表示を模倣して、プロットされた曲線（表示されている場合）をグレーアウトさせる。
 2. バリデーションが完了し、入力が無効であるか、バリデーションが失敗した場合は、曲線全体を削除する。
 3. バリデーションが正常に完了し、入力が有効である場合には、実際のプロットを行う。

プロット処理中に、`stack_js.get_content` を使用してバリデーション出力内に存在する名前付き `<div>` のコンテンツを取得する。そのコンテンツはJSONとして解析され、既存の曲線を更新するか、新しい曲線を作成するために使用される。グレーアウトもリセットされる。バウンディングボックスもサーバー側で評価されているため（JSXGraph側で評価する方が合理的であるが）、それも設定する。

## 一般的な注意事項

ここで使用している手法はすべて有効に使用できるが、バリデーションフェーズに不必要な処理を詰め込みすぎないように注意する。追加の処理が増えるほど、即時性が損なわれる。

従来は、これと全く同様の処理を、PRTフィードバックを通じて実現してきた。フィードバック内に直接プロットを含めるか、あるいは名前付きの `<div>` 要素を含めておき、ページの読み込み時に問題テキストレベルのプロットへと読み込ませるという手法である。その場合、ページの読み込みは一度しか発生せず、PRTフィードバックの更新もページの読み込み時にしか行われないため、リスナー（状態を監視する仕組み）は必要なかった。

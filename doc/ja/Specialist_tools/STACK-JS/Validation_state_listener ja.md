# バリデーション状態リスナーと追加バリデーションメッセージ

このページでは、STACKライブラリの例題 *Doc-Examples > Specialist-Tools > STACK-JS > Validation state listener* について解説します。この例題は、それほど効率的ではない方法で組み合わせた高度な機能のデモンストレーションです。意図的に作成された注意喚起の例であり、基本的には正しく動作します。

## 例題の特徴

この例題では、JSXGraphを使用して (x,y) 座標のリストを曲線としてプロットします。つまり、関数を描画します。ただし、通常とは異なる点として、インスタントバリデーションに応じてプロットを行えるように、これらの座標をカスタムのバリデーションフィードバック内で生成している点です。新しいフィードバックを検知してグラフの更新を発火させるために、バリデーション状態リスナー（validation state listener）が使用されています。

### カスタムバリデーション

解答欄には、カスタムバリデーションテスト（解答の有効性に関する検証テスト）と応答メッセージを設定できます。これらのいわゆる[カスタムバリデータ](../../CAS/Validator.md)は、受け取った入力に対して動作し、学生に表示される出力を生成できます。この例題では、問題にバリデータとフィードバックジェネレータの両方が含まれています。バリデータは、入力がxの関数であり、それ以外のものでないことを検証します（プロットが可能であるかを確認するため）。フィードバックジェネレータは、あらかじめ決められた範囲内の200点で入力を評価し、それらの点をJSON形式でエンコードした隠し `<div>` を出力します。

バリデータとフィードバックジェネレータの両方は問題変数で定義され、解答欄のその他のオプションを通じて解答欄に紐付けられます。なお、生成されるフィードバックは名前付きの `<div>` を使用しており、その名前は [`[[quid]]`](../../Authoring/Question_blocks/Static_blocks.md#quid-question-unique-identifier-block) ブロックを使用して問題の使用レベルで一意にされていることに注意してください。これは、ロジック内で名前付きの要素を参照する際に推奨される手法です。

この問題の主な課題はフィードバックジェネレータに関連しています。200点分のデータは応答メッセージ内で容量を占め、即時と見なせないほど応答を遅くする可能性があります。さらに、その関数がそれらの点で実際に評価可能かどうかを確認するための、合理的な実行時間内で動作するバリデータは存在しません。

### JSXGraph内でのSTACK-JS

この問題では、[JSXGraph](../JSXGraph/index.md)を使用してプロットを行いますが、このケースではJSXGraphを解答欄に接続しません。そのため、通常使用する入力参照やバインディング関数は使用しません。代わりに、バリデーション状態リスナー（`stack_js.register_validation_state_listener`）を使用し、バリデーションのさまざまな状態に応じて異なる処理を行います。

 1. バリデーションの開始時には、通常のバリデーション表示を模倣して、プロットされた曲線（表示されている場合）をグレーアウトさせます。
 2. バリデーションが完了し、入力が無効であるか、バリデーションが失敗した場合は、曲線全体を削除します。
 3. バリデーションが正常に完了し、入力が有効である場合には、実際のプロットを行います。

プロット処理中に、`stack_js.get_content` を使用してバリデーション出力内に存在する名前付き `<div>` のコンテンツを取得します。そのコンテンツはJSONとして解析され、既存の曲線を更新するか、新しい曲線を作成するために使用されます。グレーアウトもリセットされます。バウンディングボックスもサーバー側で評価されているため（JSXGraph側で評価する方が合理的ですが）、それも設定します。

## 一般的な注意事項

ここで使用している手法はすべて有効に使用できますが、バリデーションフェーズに不必要な処理を詰め込みすぎないように注意してください。追加の処理が増えるほど、即時性が損なわれます。

従来は、これと全く同様の処理を、PRTフィードバックを通じて実現してきました。フィードバック内に直接プロットを含めるか、あるいは名前付きの `<div>` 要素を含めておき、ページの読み込み時に問題テキストレベルのプロットへと読み込ませるという手法です。その場合、ページの読み込みは一度しか発生せず、PRTフィードバックの更新もページの読み込み時にしか行われないため、リスナー（状態を監視する仕組み）は必要ありませんでした。

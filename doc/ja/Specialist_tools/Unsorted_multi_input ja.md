# 順不同の複数解答欄

複数の独立した解答欄がある問題で、学生がどの順番で入力するかわからないケースはよくある。

例えば、線形性を利用して積分を分解する問題を考えてみる。
\\[ \\int x^2+\\sin(x) \\mathrm{d} x = \\int {\\color{red}?} \\mathrm{d} x + \\int {\\color{red}?} \\mathrm{d} x\\]
ここで `?` は解答欄 `ans1` と `ans2` に対応している。`ans1=x^2` が期待される解答かもしれないが、もちろん `ans1=sin(x)` という入力も考えられる。

もう1つの方法は、複数の解答欄から_集合_を作成することである。

1. 各入力の基本的な性質を、対応するPRTで確認する。
2. 解の集合全体としての性質を確認する。

サンプル問題はSTACKライブラリの `Topics\Complex_cube_roots.xml` にある。

### フィードバック変数を使用する方法

1つの方法として、フィードバック変数で `sans:ans1+ans2` と定義する方法がある。これにより、PRTで `sans` が被積分関数と可換性・結合性の範囲で等価であるか（または必要に応じて他の基準で）を確認できる。ただし、この方法では部分点の付与が難しいという問題点がある。

### 一部が正解の場合に部分点を与える方法

学生が一部の解答欄のみ正解している場合に、部分点を与えたいことがある。

\\(n\\) 個の異なる解答欄があるとする。不足している解答の数を \\(m\\)、不要な（正答に含まれない）解答の数を \\(w\\) とすると、得点を次のように定義する。
\\[ s = \\max\\left(1-\\frac{m+w}{2n}, 0\\right)\\]
例えば、学生が \\(n\\) 個すべてを間違えた場合（\\(m=w=n\\)）、得点は0になる。
学生が必要な式をすべて入力し（\\(m=0\\)）、さらに \\(n\\) 個の不要な式も入力した場合、\\(s=\\frac{1}{2}\\) となる。
この関数は、もちろん教師の裁量で選択するものである。

上記の例では、問題変数に以下を記述する。

    ta1:x^2;
    ta2:sin(x);
    tas:{ta1, ta2};
    p:ta1+ta2;

フィードバック変数には以下を記述する。

    sans:{ans1, ans2};
    missing:setdifference(tas, sans);
    notwanted:setdifference(sans, tas);
    score:max(1-(length(missing)+length(notwanted))/(2*length(tas)),0);

上記の例の続きとして、PRTでは以下のように設定する。

1. 評価関数として `sets` を使用する（静音オプションを併用することもできる）。
2. `sans` に `{ans1,ans2}` を指定する。
3. `tans` に `tas` を指定する。
4. PRTの真・偽_両方_の分岐で、得点に `score` を割り当てる。

### 重複する入力への対処

重複がある場合（例えば、重複のある固有値など）に部分点をどのように決定すればよいであろうか。教師の正解が `[1,1,2]` の場合、上記の集合に基づく方法は使用できない。

STACKには、Maxima関数 `list_cancel(l1,l2)` が用意されている。この関数は、重複を考慮しながら `[l1,l2]` から共通の要素を取り除く。例えば、問題変数で以下のように使用する。

    sans:{ans1, ans2};
    [missing, notwanted]:list_cancel([sans, tas]);
    score:max(1-(length(missing)+length(notwanted))/(2*length(tas)),0);

なお、`list_cancel` は代数的な等価性を判定するものではなく、この関数内では2つの式が同じかどうかをMaximaの `is(ex1=ex2)` を使って判定する。そのため、状況や「同じ」ものの基準に応じて、リストの前処理が必要になる場合がある。例えば、以下の場合を考えてみる。

    l1:[x^2,x^3,x^2-1,x+x];
    l2:[x^2,x^4,(x-1)*(x+1),2*x];
    list_cancel([l1,l2]);

この結果は \\[\\left[ \\left[ x^3 , x^2-1 \\right]  , \\left[ x^4 , \\left(x-1\\right) \\,\\left(x+1\\right) \\right]  \\right] \\] となる。最後の要素はデフォルトの簡略化が行われるため取り除かれるが、\\(x^2-1\\) と \\((x-1)(x+1)\\) は `is` では同じとみなされないことに注目してほしい。この場合は、まずリストに `ratsimp` を適用することで対処できる。他の状況では、`trigsimp` や `trigrat` のような関数が必要になることもある。

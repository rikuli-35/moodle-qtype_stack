# STACKユーザー向けのMaxima入門

コンピュータ代数システム（CAS）とは、数式を記号的に扱えるできるソフトウェアである。最も一般的なのは、ユーザが何らかの計算を実行できるようにすることである。数式の評価では、計算を通して学生の解答が持つ性質を判定する。例えば、次のようなものがある。

  * [述語関数](../../en/CAS/Predicate_functions.md)を使って、1つの式が特定の性質を持つかどうかを調べる。（例：数値の中に浮動小数点が含まれているか？）
  * 解答テストによって2つの式を比較し、等価かどうかを判定する。（例：学生の式は教師の式と数学的に等価であるか？）

Maximaは、問題の一部となるような構造を持つ数学的オブジェクトの[ランダム生成](../../en/CAS/Random.md)や、関数の[プロット](../../en/CAS/Maxima_plot.md)にも使用される。

ごく単純な問題以上のSTACK問題を作成するには、いくつかのMaximaコマンドを使用する必要がある。このドキュメントはMaximaに関する詳細なチュートリアルではない。良い入門書として[Minimal Maxima](http://maxima.sourceforge.net/docs/tutorial/en/minimal-maxima.pdf)がある。本ドキュメントはこれを読んでいることを前提としている。

ただし、STACKは標準のMaximaをいくつかの点で拡張・変更している。

## オブジェクトの種類 ##

Maximaのすべてのものは「アトム」と「式」で構成されている。アトムは整数、浮動小数点数、文字列、名前のいずれかである。述語関数 `atom()` を使うことで、その引数がアトムであるかどうかを判定することができる。式は演算子と引数のリストを持つ。アンダースコア記号は演算子ではないことに注意すること。例えば、 `a_1` は Maximaでは1つのアトムとして扱われる。添字表示やLaTeX表示の微調整については、[atoms, subscripts and fine tuning the LaTeX display](../../en/CAS/Subscripts.md) を参照。

Maximaは非常に弱い型付け言語であるが、STACKでは以下のような「型」の区別が必要である。

  1. 方程式（例：先頭の演算子が等号である等式）
  2. 不等式（例 $x<1 \text{, または } x\leq 1$）
  3. 集合（例：$\{1,2,3\}$）
  4. リスト（例：$[1,2,3]$）
   Maximaでは順序付きリストは角括弧を使って入力する。例えば、`p:[1,1,2,x^2]`のように書き、要素は `p[1]` という構文で参照する。
  5. [行列](../../en/CAS/Matrix.md)  
   行列の基本構文は `p:matrix([1,2],[3,4])` である。また、各行はリストである。要素は `p[1,2]` などのように参照する。
  6. 論理式  
   これは `and` と `or` で結合された他の式の木構造である。`x=1 or x=2`といった方程式の解を表現するのに便利である。なお、これらの式のサポートはSTACK独自のものである。
  7. 式
   式は最後に来るが、単に上記のどれにも当てはまらないものとして数えられるからである。STACKは、これらの型を判定するための[述語関数](../../en/CAS/Predicate_functions.md)を定義している。

## 数値 ##

数値は評価において重要であり、数値がどのように扱われるかについては、より具体的で詳細なドキュメントがある：[STACKにおける数字](../../en/CAS/Numbers.md)。

## エイリアス ##

STACKは以下の関数エイリアス名を定義している。

    simplify(ex) := ev(fullratsimp(ex), simp);
    int := integrate

Maximaにおける絶対値関数は `abs()` として入力する。  STACK では `|` 記号、つまり `|x|` を使って入力することもできる。これは `abs` のエイリアスである。`abs(x)`はSTACKでは$|X|$と表示される。

また、STACKでは少数の関数を再定義している。

* plotコマンド`plot2d`はSTACKの問題では使用しない。代わりに`plot`を使用すること。これは[Maximaプロットページ](../../en/CAS/Maxima_plot.md)で説明している。これにより、画像ファイルがサーバ上で利用可能になる。
* 乱数コマンド`random`はSTACKの問題では使用しない。代わりに`rand`コマンドを使用すること。これは[乱数](../../en/CAS/Random.md) で説明している。これにより、擬似乱数が生成され、学生はログインするたびに同じバージョンの問題を取得することができる。

## Maximaの式の構成要素 ##

### `op(x)` 最上位の演算子
Maximaの式を分解することは非常に有用である。これを行うために、Maximaには`op(ex)`、`args(ex)`、`part(ex,n)` などのコマンドがある。これについては、Maximaのドキュメントに詳しい説明がある。

特に、`op(ex)` は式 `ex` の主演算子を返す。このコマンドはSTACK上でいくつか問題がある。

1. `op(ex)`を数値や変数名などのアトム(Maximaの述語 `atom(ex)`に関するドキュメントを参照)に対して呼び出すと、`op(ex)` はエラーを起こす。
 2. `op(ex)` は文字列を返す場合と返さない場合がある。
 3. 単項マイナスがエラーとなる。例えば、`-1/(1+x)`の場合において、期待される演算は `"/"` ではなく、`"-"` になる。

このような問題を解決するために、STACKは次のコマンドがある。

    safe_op(ex)

これは常に文字列を返す。アトムの場合は空文字列、つまり`""` を返す。また、単項マイナスの問題も処理する。

`get_safe_ops(ex)`という関数があり、式の中の`safe_op`の集合を返す。このとき、アトムは無視される。

### `get_ops(ex)` すべての演算子

この関数は、式中のすべての演算子の集合を返す。例えば、式のどこかで乗算が使われているかどうかを調べたい場合に有用である。

## STACKによって定義されたMaximaコマンド ##

問題作成時には、STACKがMaximaを使用しているのと同じ環境でMaximaのコードを試せることは非常に有用である。つまり、設定とSTACK固有の関数が読み込まれた状態である。これを行うには、[STACK-Maxima sandbox](../../en/CAS/STACK-Maxima_sandbox.md)を参照すること。

STACKは様々な追加関数を作成し、利用可能な関数を制限しているが、その多くがこのドキュメント内で説明されている。[述語関数](../../en/CAS/Predicate_functions.md)も関連項目である。


| コマンド | 説明 |
| --- | --- |
| `factorlist(ex)` | `ex` の因数のリストを乗法の有無にかかわらず返す。なお、これらの因数の積は元の式とは一致しない場合があり、単項マイナスの抽出や変数の並び順により、 $\pm 1$の因数のみ異なる場合がある。このため、`f1` が `ex` の因数であるかどうかを判断したい場合は、因数リストの包含を調べるよりも `remainder(ex,f1)` が0であるかどうかを確認する方がよい。例えば、`remainder(a^2-b^2,b-a)`と`remainder(a^2-b^2,a-b)`はどちらも0であるが、`factorlist(a^2-b^2)`は `[b-a,b+a]` を返し、この中には`a^b`は因数として含まれていない。|
| デフォルトでは、リストは重複を含まない。リストに重複を含める場合は、factorlist(ex, true) を使用する。|
| `zip_with(f,a,b)` | この関数は、二項関数$\mathrm{f}$を2つのリスト$\mathrm{a}$と$\mathrm{b}$に適用し、リストを返す。|
| `zip_with_matrix(f,A,B)` | この関数は、二項関数$\mathrm{f}$を2つの行列$\mathrm{A}$と$\mathrm{B}$に適用し、行列を返す。行列の加算の例が[show working](../../en/CAS/Matrix.md#Showing_working)に示されている。 |
| `coeff_list_nz(ex,v)` | この関数は、式`ex`を受け取り、`v`の0でない係数のリストを返す。 |
| `divthru(ex)` | 代数分数（例えば($\frac{x^4-1}{x+2}$)）を受け取り、分母で割りきることで多項式と真分数に分ける。フィードバックや計算過程の記述に有用である。 |
| `stack_strip_percent(ex,var)` | `ex`から`%`文字で始まる変数を削除し、それらを`var`の変数に置き換える。  solveやode2などで使用する際に有用である。[solve と ode2](../../en/Topics/Differential_equations/Assessing_Responses.md#Solve_and_ode2)を参照すること. |
| `exdowncase(ex)` | 式`ex`を受け取り、すべての変数を小文字に置き換える(Maximaの`sdowncase(ex)`を参照)。  学生が大文字・小文字を誤って使用しても問題にしない場合、[解答テスト](../../en/Authoring/Answer_Tests/index.md)をを行う前に、この関数を解答に適用することは非常に有用である。なお、`exdowncase(X)-x=0`となることに注意すること。 |
| `stack_reset_vars` | 定数($\mathrm{i}$など)を抽象記号としてリセットする。[数値](../../en/CAS/Numbers.md)を参照すること。|
| `safe_op(ex)` | 式の演算を文字列として返す。アトムは（`op`のようにエラーを出すのではなく）空文字列を返す。 |
| `comp_square(ex,v)` | 変数`v`に関する二次式`ex`を平方完成した形で返す。 |
| `degree(ex,v)` |　変数`v`に関する`ex`の展開形の次数を返す。Maximaの`hipow`コマンドも参照すること。 |
| `unary_minus_sort(ex)` | `simp:false`の場合に、式中の単項マイナスの表現方法を整理する。  [simplification](../../en/CAS/Simplification.md)も参照すること。

## 代入 ## 

Maximaにおける変数への値の代入は非常に独特である。

| 入力 | 結果 |
| --- | --- |
| `a:1` | aに値1を代入する。 |
| `a=1` | まだ解かれていない方程式。 |
| `f(x):=x^2` | 関数の定義。 |

STACKでの単純な代入では、より一般的な形式である`key : value`を使用する。例えば、

    n : rand(3)+2；
    p : (x-1)^n；

もちろん、これらの代入では式を操作するためにMaximaの関数を利用することができる。

    p : expand( (x-3)*(x-4) )；

もうひとつの一般的な操作は置換である。これはMaximaの `subst` コマンドで実行できる。これは非常に有用であり、例えば、次のように$\mathrm{p}$を定義すると、応答処理において学生の解答が奇関数であるかどうかを判定できる。

    p : ans1 + subst(-x,x,ans1)；

このようにして、補間しているかどうかといった様々な性質を確認することができる。他の例として、$\mathrm{x = a}$のおける$\mathrm{f(x)}$の停留点を考えると、次のように確認することができる。

    p : subst(a,x,diff(ans1,x))；

ここでは、`a`が学生に与えられた点であり、`ans1`が学生の解答、そして`p`が応答処理で使用されると仮定している。

Maximaのループ構造は問題変数内で使用することができる。例えば、

    n : 1;
    for a:-3 thru 26 step 7 do n:n+a；

の結果は、$\mathrm{n = 56}$となる。問題内で使用するために、問題変数内で関数を定義することも可能である。

    f(x) := x^2；
    n : f(4)；

## 対数 ##

STACKはMaximaの追加パッケージ `log10` を読み込める。  これにより、底10の対数が自動的に定義される。また、STACKは2つのエイリアスを作成する。

1. `ln`は$\mathrm{log}$のエイリアスであり、自然対数である。
2. `lg`は、$\mathrm{log_{10}}$のエイリアスであり、底10の対数である。`log`というコマンドを底10の対数として再定義することはできない。

## 集合・リスト・シーケンス、組 ##

カンマ区切りのリストや組のような式を表示できることは非常に有用である。

$$
    1,2,3,4,\cdots \\[2ex]
    (1,2,3,4) 
$$

Maximaにはリスト用の組み込み関数があり、角括弧$[1,2,3,4]$で表示され、集合は波括弧$\{1,2,3,4\}$で表示される。
Maximaには組やシーケンスに対するデフォルトの関数はない。

STACKは不活性関数`sequence`を提供している。これは単に引数を括弧なしで表示するだけである。例えば、`sequence(1,2,3,4)`は、 $1,2,3,4$ と表示される。STACKには便利な関数もある。

* `sequenceify`は、式の引数からシーケンスを作成する。これによりリストや集合などがシーケンスに変換される。
* `sequencep`は、その式がシーケンスかどうかを判定する述語である。
* アトム`dotdotdot`は、texの`\ldots` を使って表示される。このアトムは学生が入力することはできない。

STACKは不活性関数`ntuple`を提供している。これは単に引数を丸括弧で表示するだけである。例えば`ntuple(1,2,3,4)`は$(1,2,3,4)$と表示される。

* `n-tupleify`は、式の引数からn組を作成する。これによりリストや集合などがn組に変換される。
* `ntuplep` は式がn組であるかどうかを判定する述語である。

Maximaの厳密な構文では `(a,b,c)` は `block(a,b,c)` と等価である。学生が `(a,b,c)` をSTACKで入力した場合、それは`ntuple(a,b,c)` に変換される。教師は問題変数、模範解答、テストケースなどを構築する際には、`ntuple`関数を明示的に使用しなければならない。`ntuple`は学生が座標を入力するのに有用である。

これらの関数を使用する場合は、次のように問題変数を作成する。

    L1:[a,b,c,d]；
    D1:apply(ntuple, L1)；
    L2:args(D1)；
    D2:sequenceify(L2)；

`L1`はリストであり、通常通り角括弧で表示される。`D1`は演算子`ntuple`を持ち、丸括弧で表示される。`L2` は演算子 `list`を持ち、角括弧で表示される。最後に、`D2`は `sequence`であり、括弧なしで表示される。

もちろん、これらの関数を直接適用することもできる。

    T1:ntuple(a,b,c)；
    S1:シーケンス(a,b,c,dotdotdot)；

PRTの比較で`sequence`や`ntuple`を使用する場合は、それらをリストに戻した方が良い。例えば、`ntuple(1,2,3)` は `[1,2,3]` と代数的に等価ではない。これを行うには `args` 関数を使用する。将来的には、`sequence`や`ntuple` のデータ型により積極的な意味を持たせるかもしれない。

現在、学生は「暗黙のn組」を含む式を入力できる。例えば、

* 学生が `(1,2,3)`と入力すると`ntuple(1,2,3)`と解釈される。
* 学生が`{(1,2,3),(4,5,6)}`と入力すると`{ntuple(1,2,3),ntuple(4,5,6)}`と解釈される。
* ntupleに対しては演算が定義されていないため、学生は`(1,2,3)+s*(1,0,0)`のような式は入力できない。教師が式`ntuple(1,2,3)+s*ntuple(1,0,0)`を定義すること自体は可能だが、演算`+`や`*`はntuplesに対して定義されていないため、何も起こらない。もし学生に直線や平面の方程式を入力させたいのであれば、ベクトル用の行列構文を使用するべきである（これは将来変更される可能性がある）。

行列には、括弧の表示を制御するオプションがある。また、行列はカンマなしで表示される。

javascriptと連携する場合は、`sequenceify`を使用しないこと。[JSXGraph](../Specialist_tools/JSXGraph/index.md)のようなjavascriptと連携する場合、LaTeXやMaximaの通常の括弧記号を含まない値のリストを出力したい場合がある。その場合は以下を使用すること。

    stack_disp_comma_separate([a,b,sin(π)])；

この関数は、リストを波括弧なしの引数の文字列表現に変換する。
内部的には、値のリストに `string` を適用します（TeXではない）。ただし、出力に`%pi`のようなものが含まれる場合がある。

これを数式入力とともに使用することができる。`{@stack_disp_comma_separate([a,b,sin(pi)])@}`とすると、`a, b, sin(%pi/7)`（文字列の引数符なし）が得られる。これは、Maximaの変数が文字列の場合、外側の引用符を取り除き、数式モードではタイプセットしないためである。


## 関数 ##

教師がSTACK問題の一部として関数を定義することは有用である。これはMaximaの通常の記法を用いて行うことができる。

     f(x):=x^2；

Maximaの`define()`コマンドを使用することは禁止されている。代わりに`lambda`コマンドを使って`f`を「無名関数」として定義することができる。

     f:lambda([x],x^2)；

ここでは「無名関数」に名前をつけており、少し逆説的に見える。無名関数は多くの場面で非常に有用である。

例えば、区分関数は次のいずれかコマンドで定義できる。

     f(x):=if (x<0) then 6*x-2 else -2*exp(-3*x)；
     f:lambda([x],if (x<0) then 6*x-2 else -2*exp(-3*x))；

これを使って次のようにプロットできる。

    {@plot(f(x),[x,-1,1])@}

# Maximaの落とし穴 #

  * Maxima には多項式の次数を求める `degree` コマンドが存在しない。ここでは、`hipow`コマンドを用いて定義している。
  * 行列の乗算はドット、例えば `A.B` で表す。アスタリスクの `A*B` は要素ごとの乗算を表す。
  * アトム `a1` と `a_1` は代数的に等価とはみなされない。

## さらなる情報とリンク ##

* [最小限のMaxima](http://maxima.sourceforge.net/docs/tutorial/en/minimal-maxima.pdf)
* [SourceForge上のMaxima](http://maxima.sourceforge.net)

## 関連項目

[Maximaリファレンストピック](../../en/CAS/index.md#reference)

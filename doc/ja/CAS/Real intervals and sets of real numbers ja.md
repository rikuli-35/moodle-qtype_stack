# 実数区間と実数の集合

STACKには、実数区間および実数の集合を表現し、扱うための簡単なシステムがある。

単純な実数区間は不活性関数 `oo(a,b)`、`oc(a,b)`、`co(a,b)`、`cc(a,b)` によって表現することができる。ここで、`o`は開端点を表し、`c`は閉端点を表す。つまり、`oc(-1,3)`は区間$\{x \in \mathbb{R} \mid -1 \lt x \text{ かつ } x \leq 3\}$であり、英国数学の慣習に従って、不揃いの括弧で$\mathrm{(-1,3]}$と表示される。

Maximaの`union`関数は引数を集合にする必要があるが、区間は集合ではない。単純な区間を結合して離散集合と組み合わせるには、（パッケージ`to_poly_solve`に含まれる）`%union` 関数を使用する必要がある。例えば、 `%union(oo(-2,-1),oo(1,2))`のようにする。

`%union`関数は（`simp:false`を設定していない限り）引数をソートし、ソートは`oo(-inf,a)`の形の単純区間を右端に置いて順序が崩れるように並べてしまうことに注意すること。順序を保持するため、いくつかのソート関数は期待される`%union`ではなく、区間のリストを返す。

`%union`コマンドは、単純区間と離散的な実数の集合の両方を引数に取ることができる。例えば、

    %union(oo(-inf,0),{1},oo(2,3));

同様に、STACKは区間の共通部分を表すための`%intersection`も提供している（これは`to_poly_solve`パッケージには依存しない）。


述語関数

1. `intervalp(ex)`は、`ex` が単一のの単純区間であればtureを返す。`ex` が無変数であるかどうかは判定しないため、`oo(a,b)`も単純区間とみなされる。この述語では、`{}`, `none`, `all`および単元集合は区間とみなされないため、`realsetp`を使用すること。この述語の主な目的は、コード内の区間`oo`, `oc`などを検出することである。
2. `inintervalp(x, I)`は、`x` が `I` の要素であればtureを、そうでなければfalseを返す。`x`は実数でなければならない。`I`は数値の集合か、`oo(a,b)`などの単純区間でなければならない。
3. `trivialintervalp(ex)`は、`ex`が$\mathrm{(a,a)}$のような自明な区間であればtrueを返す。
4. `unionp(ex)`は、その演算子が和集合であるかどうかを判定する。
5. `intersectionp(ex)`は、その演算子が共通部分であるかどうかを判定する。
6. `realsetp(ex)`は、`ex` が明確な実数集合（例えば、区間の和集合）を表していればtureを返す。すべての端点および集合の要素は実数でなければならないため、`oo(a,b)`は`realset`ではない。変数を集合や端点として使用したい場合は、`realset_soft_p`を使用すること。
7. `interval_disjointp(I1, I2)`は、2つの単純区間が互いに素かどうかを判定する。
8. `interval_subsetp(S1, S2)`は、実数集合 `S1`が実数集合`S2`に含まれているかどうかを判定する。
9. `interval_containsp(I1, S2)`は、単純区間`I1`が実数集合`S2`の中に明示的な部分区間として含まれているかどうかを判定する。ここでは真部分集合を扱わないが、学生がどの区間を解答しているかを確認するのに有用である。

区間のの基本的な操作

1. `interval_simple_union(I1, I2)`は、2つの単純区間を結合する。
2. `interval_sort(I)`は、区間のリストを受け取り、左端値に基づいて昇順に並び替え、リストを返す。
3. `interval_connect(S)`は、区間の`%union`が与えられた場合、互いに接している区間があるかどうかを調べ、もしあればそれらを結合し、修正されたunionを返す。
4. `interval_tidy(S)`は、集合の和集合が与えられた場合、この和の「標準形」を返す。
5. `interval_intersect(S1, S2)`は、2つの単純区間、または2つの実数集合（`%union`で表された集合など）の共通部分を求める。
6. `interval_intersect_list(ex)`は、実数集合のリストの共通部分を求める。
7. `interval_complement(ex)`は、区間の`%union`を受け取り、その補集合を返す。
8. `interval_set_complement(ex)`は、実数の集合を受け取り、その実数を含まない区間の`%union` を返す。
9. `interval_count_components(ex)`は、実数の集合を受け取り、式全体に含まれる個別の連結成分の数を返す。単純区間は1つとして数えられ、集合はその集合内に含まれる異なる点の個数として数えられる。空集合のような自明な区間は0として数えられる。簡約は行われないため、単なる表現ではなく実際の要素の数を求めたい場合は、`interval_tidy(ex)`を事前に使用しなければならない場合がある。

## 自然定義域および変数を伴う実数集合

`natural_domain(ex)`関数は、式`ex`で表される関数の自然定義域を、不活性関数`realset`の形式で返す。例えば、 `natural_domain(1/x)`は以下を返す。

    realset(x,%union(oo(0,inf),oo(-inf,0)))；

不活性関数`realset`は、変数と数値の集合を一緒に渡すことができる。これは主に、自然定義域を分かりやすい形で表示するためのものである。例えば、区間の補集合が離散集合である場合、`realset`は、通常の$x \in \cdots$という表示ではなく、$x \notin \cdots$と表示される。多くの場合で、より読みやすく理解しやすい表記である。

    realset(x,%union(oo(0,inf),oo(-inf,0)))；

上記は、$x\notin\{0\}$と表示される。

## 学生の解答の検証

学生は単に`union`（`%union`ではない）などと入力しなければならない。

学生の解答の検証は「型」という概念は非常に緩く扱われる。  解答の「型」を確認する際、教師側の解答が集合である場合、学生の解答も集合である必要がある(`setp` を参照)。区間が有効であるとみなされる文脈において、教師側の解答がで実際には集合であった場合、教師側の解答はsetではなく、`realset`になるように不活性関数`%union`を用いる必要がある。例えば、`%union({1,2,3})`となるようにする。

検証ではいくつか簡単な確認が行われ、`oo(1)`や`oo(4,3)`のような不正な形式の区間は無効として拒否される。

## 学生の解答の評価

代数的等価性の解答テストは必要に応じて`interval_tidy` を適用し、その結果を比較する。現在、この解答テストによって提供されるフィードバックは最小限のものである。

学生の入力が区間である場合、Maximaの`first`関数と`last`関数を通して、上端および下端の境界にアクセスすることができる。例えば、区間の端点が正しいかどうかを判定するPRTノード (ただし、`co`や`oo`のような区間の種類までは問わない。) は、学生の解答`[first(ans1), last(ans1)]`と教師側の解答`[first(ta1), last(ta1)]`の代数的等価性を判定することで実行できる。

学生はしばしば、一般的な表記法に従って閉区間を`[a, b]`、開区間を`(a, b)`と入力する。しかし、STACKでは`[a, b]`はリストとして解釈される。そのため、次のようにして`cc(a,b)`に変換できる。

    ans1interval : if listp(ans1) then cc(first(ans1), last(ans1)) else ans1;

同様に、`(a, b)`という解答は`ntuple(a,b)`として解釈される（[集合、リスト、数列、組](<../CAS/Introduction to Maxima for STACK users ja.md>)を参照）。組に対する直接の判定関数は存在しないが、次のようにして`oo(a,b)`に変換できる。

    ans1interval : if is(safe_op(ans1) = "ntuple") then oo(first(ans1), last(ans1)) else ans1;



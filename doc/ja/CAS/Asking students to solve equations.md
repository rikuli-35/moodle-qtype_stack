# 方程式を解かせる問題の出題

学生に代数方程式を解かせることはよくあることである。学生の解答は数のリスト（または集合）になることがある。この解答について、

1. 正確性：リスト内のすべての要素がその方程式を満たしている
2. 完全性：方程式のすべての解がそのリストに含まれている


(1)の確認を行う最善の方法は、正解のリスト/集合と代数的に等価かどうかを直接比較することではない。そうではなく、学生の解答を方程式に代入し、実際に成り立つかどうかを確認する方法を使う。

例を挙げて説明する。教師が、学生に次の「問題変数」で定義された方程式において`p=0`を解くように求めたとする。

    p:2*x^2+11*x-5/4；
    ta:solve(p,x)；
    /* solveは「方程式のリスト」を返すが、ここでは数の集合が欲しい。*/
    ta:setify(maplist(rhs,ta))；

解の集合について順番は重要ではないが、重複度（同じ解が何回出るか）が重要である。  したがって、論理的には"bag"（多重集合）が必要である。しかし、Maximaには集合とリストしかない。

学生が集合やリストを入力した場合、AlgEquiv解答テストを使って集合やリストを比較することはできるが、これは要素ごとの一致で比較されてしまう。そのため、ここでは別の方法が必要となる。

そこで、フィードバック変数内で学生の解答を `ans1` とし、"listans"という新しいリストを作成する。

    /* ここから先は、順番を確定させるために*リスト*が必要。*/
    sans:listify(ans1)；
    /* 方程式に代入する。*/
    listans:maplist(lambda([ex],ev(p,x=ex)), listify(ans1))；

`listans`の値は、学生の各解答を方程式にそれぞれ代入したときに得られる値である。これを簡約することもできるが、厳密には必要ない。

    /* 結果を「簡約」する（厳密には必要ない）。*/
    listans:maplist(fullratsimp,listans)；

これで数値のリストが得られた。次はこれを何かと比較する必要があるが、学生のリストに含まれる要素数が、教師側の解答の個数と異なる可能性がある点に注意が必要である。

    /* このリストと比較するためのものを生成する。*/
    zl:makelist(0,length(listans))；

ポテンシャル・レスポンス・ツリーでは、AlgEquiv解答テストを使用して`listans`と`zl`を比較し、フィードバックをすべて抑制するために`quiet=yes`オプションを指定する。

次に、学生の解答リストの中で、どの解答が誤っているかを特定する。

    /* リスト内の解答どうしが等価かどうかを判定する。*/
    /* 誤っている解答を取り出す。*/
    we:sublist(sans, lambda([ex], not(algebraic_equivalence(ev(p,x=ex),0))))；

これを利用するには、最初のノードの`false`分岐のフィードバック欄に、次のような内容を記述する。

    The following answers you entered do not satisfy the equation
    \[ {@we@}. \]

上記のテストは、学生が入力したすべて値が方程式を満たしていることのみを確認する。特に、空集合 `{}` であってもこのテストに合格してしまう。したがって、学生がその方程式の解をすべて挙げているかどうかを確認する必要がある。
そのために、教師側の解答の個数が学生の解答の個数より多いかどうかを調べる。これは次のテスト（すなわち、「より大きい」テスト）で実行できる。

    ATGT(length(ta), length(fullratsimp(sans)))

このテストが真であれば、学生はいくつかの解を見落としていることになる。

ここで重要なのは、特定の数の集合との等価性を確認したいのではなく、正確性（学生が挙げた値はすべて方程式の解であるか）と完全性（すべての方程式の解を学生が挙げているか）を別々に確認している、ということである。

## ランダムに生成された変数

上記の例では、ランダムに生成された変数を使っている場合がある。例えば、

    v:rand([x,y,z,t])；
    p:a*v^2+b*v+c；

この場合、代入を正しく行うには追加の評価を入れる必要がある。

    listans:maplist(lambda([ex],ev(p,ev(v=ex))), listify(ans1))；


## 重解について

教師が学生に集合として解答を入力させる場合、STACKはデフォルトで重複要素を削除しない。 これはバリデーションが`simp:false`で実行されるためである。学生に重解を重複回数も含めて入力させたい場合は、学生の解答から解が失わないようにPRT上で`Auto-simplify` を `no` に設定する必要がある。そのうえで、各解答が方程式を満たしている、かつ学生の解答数が正しい個数であるかを確認する。
個数の確認には、

    length(ans1)

を用い、正しい個数との比較には、簡約を避けるために`EqualComAss`を使う。
ここで、`ans1`を"簡約"すると、集合が自動的に重複を削除するため、解が失われる可能性がある。

別の方針として、学生の解答をあえて簡約し、異なる解の個数が正しいかどうかを確認したい場合がある。以下は別の種類のテストである。

    length(fullratsimp(ans1))

最終的にどの方法を使うか、また、教師が重解を正しい回数分入力させるかどうかは、問題の設定次第である。

## LaTeX の `aligned` 環境で方程式を表示する

STACKは`begin{aligned} ....\end{aligned}`環境をサポートしており、等号の位置で方程式を綺麗に揃えて表示することができる。これは引数を表示するだけの不活性関数である。

例えば、CASTextで`{@aligned([x^2+2,stackeq(3)],[x^3,stackeq(4)])@}`を試してみると良い。

問題変数では 

    /* 以下のeq1の定義はどちらでもよい。*/
    eq1:x^2+2=3 nounand x^3=4；
    eq1:[x^2+2=3, x^3=4]；
    eq2:apply(aligned, map(lambda([ex], [lhs(ex),stackeq(rhs(ex))]), args(eq1)))；

を表示し、通常通り`{@eq2@}`を表示する。

また、STACK は不活性関数 `lrparens` をサポートしており、LaTeX出力における `left` と `right` の括弧を細かく制御することができる。例えば、

    eq2:lrparens(".", ex, "\\}")；

は式 `ex` のLaTeX出力を `\left.` と `right\}` で囲む。lrparensの第1引数と第3引数は文字列でなければならず、これらはLaTeXの正当な括弧に対応している必要がある。通常通り、波括弧はエスケープする必要がある。
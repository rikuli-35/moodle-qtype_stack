# 置換を互いに素な巡回の積として書く

ここで、
$$
\mathrm{f}= \begin{pmatrix}
1 & 2 & 3 & 4 & 5 & 6 & 7 \\
3 & 1 & 5 & 7 & 2 & 6 & 4 
\end{pmatrix}
$$

純粋数学では、このような置換を互いに素な巡回の積として書くように学生に求めることがある。

その方法の一つは、1-巡回も含めて、解答をリストとして入力させることである。例えば、置換$(1)(2,3)$は`[[1],[2,3]]`のように入力する。

このリストはリストの集合に変換することができるのため、互いに素な巡回の順序は重要ではない。しかし、各順序をは特定の方法で書く必要がある。例えば、`[2, 3, 4]`と`[3, 4, 2]`は等価であるとみなしたい。

これを行う方法の一つは、リストを巡回させることで、各リストの先頭要素がそのリストの最小要素になるようにすることである。つまり、各巡回を確定的な形に書き直すということである。次のコードは、1つの巡回に対して行う。この関数は問題変数内で使用できる。

    /* 最小の要素を先頭に持つ巡回を書く。明確な順序を与える。*/
    perm_min_first(ex) := block(
        if length(ex)<2 then return(ex)、
        if is(first(ex)<apply(min, rest(ex))) then return(ex)、
        return(perm_min_first(append(rest(ex), [first(ex)]))).
    );

学生の解答`ans1`が`[[1],[2, 3]]`と入力されたとする。フィードバック変数内で、以下のコードで用いて`ans1`内の各リストの先頭要素が最小になるようにする。

    sa1:maplist(perm_min_first, ans1)；

次に、代数的等価判定(quiet)を用いて、`setify(sa1)`と(同様の処理が施した)教師側の解答を比較する。

これは、特定のデータ型やそれに対応する等価判定が存在しない場合でも、学生の解答を前処理することで、適切な等価性を確立できる良い例である。 
# STACKにおける数値

以下については別ページで解説されている。

1. [数値の解答テスト](../Authoring/Inputs/Numerical_input.md)
2. [複素数](../CAS/Complex%20Numbers%20in%20STACK.md)
3. [数値の四捨五入](../CAS/Numerical%20rounding.md)

## 正確な定数 ##

Maximaでは、特別な定数は次のように定義されている。

    i、%e、%pi

STACKでは単一文字の別名も使用されている。例えば、

    e: %e
    pi: %pi

問題設定によっては以下が定義されている場合もある。

    i: %i
    j: %i

$\mathrm{e}$などの定数を、数値ではなく抽象的な記号として使用したい場合がある。通常のMaximaでは`kill()`コマンドを使うが、STACKではセキュリティ上の理由から使用することができない。代わりに、問題変数で `stack_reset_vars(true)` を使用する。これによりSTACKによって定義されたすべての特別な定数がリセットされ、個々のSTACKの問題で記号を再定義することができる。(Maxima 5.42.1(および一部の他バージョン)では、`stack_reset_vars(true)`は`ordergreat` もリセットするため、`stack_reset_vars(true)`を使用する場合には、問題変数の最初に置く必要がある。これはMaxima 5.44.0 で修正されており、おそらくMaximaのバグであると推測される。)

定数$\mathrm{e}$の表示を変更する場合は、`texput(%e, " \mathrm{e}");`のように`%e%`の値を参照する必要がある。

## 合同算術 ##

関数`recursemod(ex, n)`は式の木構造を再帰的に処理し、`numberp` によって数値と認識された部分に関数`mod(?, n)`を適用する。`polymod`が多項式にのみ適用されるのに対して、この関数はどのような式に対しても適用可能である。

## 数値の内部表現 ##

Maximaには主に整数と浮動小数点数という2つのデータ型がある。有理数は専用のデータ型ではなく、2つの整数の除算として表現され、無理数はべき乗、または`sqrt`関数で表現される。
[平方根の表示](../Authoring/Question_options.md)についてはオプションで変更可能である。

同様に、複素数は1つのまとまりとしてではなく、実部と虚部の和として、あるいは指数関数を介して表現される。
複素数の入力と表示は、数学、物理学、工学の間で記号が異なるため、意味と表示を整理するために、[sqrt(-1)](../Authoring/Question_options.md#sqrt-1-sqrt_minus_one)というオプションが各問題に設定されている。

## 浮動小数点数 ## 

* 浮動小数点に変換するには Maximaの`float(ex)`コマンドを使用する。
* 浮動小数点を正確な表現に変換するには、`rat(x)`を使用して小数を有理化する。

変数$\mathrm{e}$が`e:exp(1)`と定義されている。これは`2*10^3`を意味する科学記数法`2e3`と衝突する可能性がある。

学生が`3e4`（これは$3\times 10^{4}$を意味する）のような科学記数法を使用することを想定している場合、[strict syntax オプション](/doc/en/Authoring/Inputs/index.md) を使用するとよい。

[数値の四捨五入](../CAS/Numerical%20rounding.md)については、別のドキュメントを参照すること。

また、有効数字の桁数を管理する仕組みがある。詳細は`dispsf(ex,n)`のドキュメントを参照すること。

## Maximaと末尾に0を持つ浮動小数点数 ##

内部表現において、Maximaは常に浮動小数点数から末尾の0を切り捨てている。例えば、Maximaの式`0.01000`は内部的に`0.01`に変換される。実際には、10進数入力を内部で2進数の浮動小数点数に変換し、再び元に戻す処理の副産物である。同様に、数値が 「float」型の場合、Maximaはそれがfloatであることを示すために、常に少なくとも1つのの小数桁を表示する。例えば、数値10の浮動小数点表現は、$\mathrm{10.0}$ である。これは有効数字を示しているのではなく、データ型を示している。有効数字の桁が重要な場合では、これは問題となる。

STACKでの数値の表示はLaTeXによって制御されており、基礎となるLISPは数値を柔軟に表現する方法を提供している。

単位入力は別として、他のすべての入力タイプでは浮動小数点数の不要な末尾の0が表示時に切り捨てられ、有効数字に関する情報を失われる。したがって、学生の解答が浮動小数点数の場合、末尾の0は表示されない。特に、有効数字を評価したい場合は、教師側の解答に単位をつけずに[単位入力タイプ](/doc/en/Topics/Units.md)を使用すること。単位入力タイプは学生が入力したものと同じ有効数字の桁数を表示する。

## LaTeXによる数値表示 ##

数値の表示はMaximaの `texnumformat` コマンドによって制御され、STACKがそれを修正している。

STACKには、整数と浮動小数点数の表示をそれぞれ制御するための2つの変数が用意されている。デフォルト値は以下の通り。

    stackintfmt:"~d"；
    stackfltfmt:"~a"；

この2つの変数は、それぞれ整数（述語 `integerp` で識別）と浮動小数点（述語 `floatnump` で識別）の出力形式を制御する。これらの変数は永続的なため、値を変更するたびに定義する必要がある。

これらの変数にはMaximaの`printf`形式に従った文字列を代入する必要があります。

これらの変数は、問題変数内で定義することで全体に効果を持たせることができる。また、Maximaのブロック内で定義することで、その場で表示や個々の式の表示を制御することも可能である。例えば、次のようなCASTextを考えてみる。

    The decimal number {@n:73@} is written in base \(2\) as {@(stackintfmt:"~2r",n)@}, in base \(7\) as {@(stackintfmt:"~7r",n)@}, in scientific notation as {@(stackintfmt:"~e",n)@} and in rhetoric as {@(stackintfmt:"~r",n)@}.

結果は、"The decimal number $\mathrm{73}$ is written in the base $\mathrm{2}$ as $\mathrm{1001001}$, in the base $\mathrm{7}$ as $\mathrm{133}$, in scientific notation as $\mathrm{7.3E + 1}$ and in rhetoric as $\mathrm{seventy-three}$." となる。

すべての浮動小数点数を通常の科学記数法にするには、次のようにする。

    stackfltfmt:"~e"；

すべての浮動小数点数を強通常の小数表示にするには、次のようにする。

    stackfltfmt:"~f"；

`stackintfmt`と適切なテンプレートを使うことで、すべての整数を浮動小数点表示や科学記数法で表示させることもできる。  この関数はLISPの`format`コマンドを呼び出しているが、これは複雑で、より多くの例が [オンライン](http://www.gigamonkeys.com/book/a-few-format-recipes.html) 上にある。

| テンプレート | 入力 | TeX出力 | 説明/注釈
| --- | --- | --- | --- |
| `"~,4f"` | `0.12349` | $\mathrm{0.1235}$ | 小数点以下4桁を出力：浮動小数点表示
| | `0.12345` | $\mathrm{0.1234}$ | 四捨五入に注意
| | `0.12` | $\mathrm{0.1200}$ | | |
| `"~,5e"` | `100.34` | $\mathrm{1.00340e+2}$ | 小数点以下5桁を出力：科学記数法 
| `"~:d"` | `10000000` | $\mathrm{10,000,000}$ | 3桁ごとにカンマで区切る
| `"~,,\' ,:d"` | `10000000` | $\mathrm{10\text{ }000\text{ }000}$ | 3桁ごとにスペースで区切る
| `~r` |`9` | $\text{nine}$ | 英語表記
| `~:r` | `9` | $\text{ninth}$ | 序数の英語表記
| `~7r` | `9` | $\mathrm{12}$ | 7進法
| `~@r` | `9` | $\text{IX}$ | ローマ数字
| `~:@r` | `9` | $\text{VIIII}$ | 旧式ローマ数字

LISPのformatコマンドには他にも多くのオプションがある。英語表記およびローマ数字の場合、数値はLaTeXの数式環境内で表示されることに注意すること。

現在、`@`記号はCASText内の文字列内では正しく解析されない。つまり、現在 `{@(stackintfmt:"~@r",4)@}`をCASTextに入力することはできない。これは既知のバグである。この問題を回避するには、問題変数で変数（例：`roman:"~@r";`）を定義し、CASTextでその変数名（例：`{@(stackintfmt:roman,4)@}`）を使用する。

Maximaには、計算時および計算結果の表示に使用する小数点以下の桁数を制御するためのシステムがある。値の表示には末尾の0は出力されない。これはMaximaの`fpprec`変数と`fpprintprec` 変数によって制御される。STACKのデフォルト値は以下の通り。

    fpprec:20, /* 20 桁で作業する。*/
    fpprintprec:12, /* 12桁のみ印字。*/

## 小数の区切り記号の変更（例：小数の区切りにカンマを使用する） ##

STACKは小数点の区切り記号を変更し、小数の区切りにカンマを使用する仕組みをサポートしている。問題レベルのオプションを使用して、小数点記号として`,`または`.`を選択できる。問題内の他の部分でより細かい制御をするには、次の変数を設定する。

    stackfltsep:","；

グローバル変数`stackfltfmt`と`stackfltsep`は独立した効果を持っている。

小数点としてカンマを使用するオプションを選択した場合、集合、リスト、関数の引数における区切りはカンマではなくなる。記号の衝突を避けるため、要素はセミコロン（`;`）で区切られる。

`stackfltfmt:"~:d"`のように、数字を3桁ごとにカンマで区切る設定を使用した場合、それらのカンマは曖昧さを避けるためにスペースに置き換えられる。カンマの置き換えは整数と浮動小数点数の両方に対して行われ、整数内のカンマによる混乱が生じないようにしている。

## STACKの数値関数と述語 ##

数値操作に関連する以下のコマンドがSTACKで定義されている。

| コマンド | 説明 |
| --- | --- |
| `significantfigures(x,n)` | $\mathrm{x}$を$\mathrm{n}$桁の有効数字に切り詰める（四捨五入）。
| `decimalplaces(x,n)` | $\mathrm{x}$を小数点以下$\mathrm{n}$桁に切り詰める（四捨五入）。下記参照。
| `commonfaclist(l)` | 数値のリストの最大公約数を返す。
| `list_expression_numbers(ex)` | `numberp(ex)=true`となる部分をすべて持つリストを作成する。 |
| `coeff_list_nz(ex,v)` | この関数は、式$\mathrm{ex}$を受け取り、変数$\mathrm{v}$の0でない係数のリストを返す。 |
| `numabsolutep(sa,ta,tol)` | $\mathrm{sa}$は$\mathrm{ta}$から$\mathrm{tol}$以内にあるかどうか（例：$\lvert \mathrm{sa}-\mathrm{ta} \rvert \leq \mathrm{tol}$） |
| `numrelativep(sa,ta,tol)` | $\mathrm{sa}$は$\mathrm{ta}$から$\mathrm{tol}\times\mathrm{ta}$以内にあるかどうか（例：$\lvert \mathrm{sa}-\mathrm{ta} \rvert \leq \mathrm{tol}\times\mathrm{ta}$） |
| `numexactp(sa,ta)` | この関数は、ある数が別の数と等しいかどうかを判定するが、浮動小数点数が正確な場合に限る。例えば、`ta=1/4`の場合、正確な小数$\mathrm{0.25}$を持つ。この場合、floatは有理数に変換され、比較される。しかし、`ta=1/3`の場合、この小数は有限小数にならないため、`sa`内のfloatは変換されない。 |
 
以下のコマンドは数値の表示形式を生成する。これらはその後、自動的に操作されることはないため。教師用の解答を生成する場合などの最後の段階で使用すること。

| コマンド | 説明 |
| --- | --- |
| `dispdp(x,n)` | $\mathrm{x}$を小数点以下$\mathrm{n}$桁に切り詰め、末尾の桁を表示する。これは常に浮動点小数点数（または整数）として表示され、科学記数法では表示されない。 |
| `dispsf(x,n)` | $\mathrm{x}$を$\mathrm{n}$桁の有効数字に切り詰め、末尾の桁を表示する。これは常に浮動点小数点数として表示され、科学記数法では表示されない。 |
| `displaydp(x,n)` | $\mathrm{x}$を小数点以下$\mathrm{n}$桁で末尾の桁を含めて表示することを記録する不活性内部関数。この関数は四捨五入を行わない。|
| `displaysci(x,n,expo)` | $\mathrm{x}$を小数点以下$\mathrm{n}$桁で末尾の桁を含めて科学記数法で表示することを記録する不活性内部関数。（例：$\mathrm{x}\times 10^{\text{expo}}$） |
| `scientific_notation(x,n)` | $\mathrm{x}$を$\mathrm{m}10^\mathrm{e}$の形式で表示する。`simp:false`のときのみ確実に動作する(例えば9000を試してみると良い)。第2引数は仮数に`displaysci(m,n)`を適用し、末尾の0の表示を制御する。 |

| 関数 | 述語 |
| --- | --- |
| `simp_numberp(ex)`｜`simp:false`の場合における`numberp(ex)`を修正する。|
| `simp_integerp(ex)` | `simp:false`の場合における`integerp(ex)`を修正する。 |
| `simp_floatnump(ex)` | `simp:false`の場合における`floatnump(ex)`を修正する。|
| `real_numberp(ex)` | $\mathrm{ex}$が実数かどうかを判定する。これには平方根や$\pi$のような記号的数も含まれる。|
| `lowesttermsp(ex)` | 有理式が既約になっているかどうかを判定する。 |
| `anyfloatex(ex)` | 式の中に浮動小数点があるかどうかを判定する。 |
| `scientific_notationp(ex)` | $\mathrm{ex}$が$\mathrm{a\times 10^n}$の形式かどうかを判定する。ここで、$\mathrm{a}$は整数または浮動小数点数、$\mathrm{n}$は整数である。 |

これらの述語関数は`simp:false`とともに使用する必要があることに注意すること。デフォルトの代数的等価判定 (`ATAlgEquiv`) を含む一部の解答テストは、常に引数を簡約する。代わりに `EqualComAss` のような簡約しない解答テストを使用すること。

### 小数点以下の桁数

`decimalplaces(x,n)`および`dispdp(x,n)`は四捨五入を行う。詳細については、[四捨五入](../CAS/Numerical%20rounding.md)に関する資料を参照すること。いくつか例外がある。

* `x`が実数でない場合（`real_numberp`で判定）、エラーを出さずに`ex`を返す。
* `n`は整数でなければならず、そうでない場合はエラーを出す。
* `n`が0の場合、Maximaの`round`コマンドで最も近い整数に四捨五入する。
* `n`が負の値であることも可能で、その場合も四捨五入を行う。例えば、`decimalplaces(314.15,-2)`は`300`となる。
* `decimalplaces(x,n)`は可能であれば整数を返す。`7.0`のような浮動点小数点数ではなく、`7`のような整数を返す。
* `dispdp(x,n)`は末尾の0（存在する場合）を表示するための不活性形式を返す。この場合、`x`は実数でなければならず、そうでない場合はエラーを出す。

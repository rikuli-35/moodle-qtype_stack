# ランダムオブジェクト

STACKでは構造を持つランダムオブジェクトを生成することができる。STACKは[Maxima](Maxima_background.md)の `rand()`関数を提供しており、問題変数および解答変数で使用できる。

STACKは特定のシードから擬似乱数を生成する。これにより、特定の学生が再度アクセスした場合でも、同じ出題形式を表示させることができる。(サイト管理者への注意: 学期の途中でMaximaのバージョンを更新した場合、乱数が変わらないという保証はない。Maximaがバージョン間で乱数生成方法を変更する可能性は低いが、重要であれば事前に確認すること。)

学習や教育という目的では、統計的に完璧なアルゴリズムは必要ない。それよりも、単純さ、効率性、そしてプラットフォーム間での再現性を重視する。したがって、擬似乱数を採用している。

学生が目にする可能性のある各ランダムバージョンを事前にテストすることは非常に重要であり、偶然に任せてはいけない。ランダム変数を事前に生成してテストするには、[ランダムな変数のデプロイ](../STACK_question_admin/Deploying.md)を参照すること。

また、ユーザは簡単に問題のすべてのバリエーションを[体系的にデプロイ](../STACK_question_admin/Deploying_systematically.md)することができる。

## rand()関数

STACKは独自の関数 `rand()` を提供している。

* `rand(n)`は$\mathrm{0}$から$\mathrm{n-1}$までの整数を生成する。
* `rand(n.0)`は$\mathrm{0}$から$\mathrm{n}$までの浮動小数点数を生成する。小数点以下の桁数を正確に制御するには、「a=float(rand(1000)/1000)」のようにした方が有用である。別の方法として、[Maxima](Maxima_background.md)の`round()`関数を使用するものがある。
* `rand([a,b,...,z])`はリストからランダム1つに選択する。
* `rand({a,b,...,z})`は集合からランダム1つに選択する。
* `rand(matrix(..))`は行列の各要素にrandを適用する。

STACKは、集合のランダム生成のために以下の関数を提供している。

* `random_subset(u)`は`u`のランダムな部分集合を返す。
* `random_subset_n(u,n)`は`u`の`n` 個の要素からなるランダムな部分集合を返す (可能な場合)。
* `random_ne_subset(u)`は`u`の空でないランダムな部分集合を返す。

Maxima自体にも乱数関数がある。例えば、ランダムなリストを作成するには`random_permutation`を使用する。

ランダムオブジェクトを作成する場合、条件文は使わない方が良い。例えば、ランダムに小さな素数を生成したい場合は、次のようにする。

    p : rand([2,3,5,7,11,13,17,19])；

これは数学的に最も洗礼された方法には見えないかもしれないが、おそらく最も信頼性が高いものである。

### rand_with_step(lower,upper,step) ###

集合`{lower, lower+step, lower+2*step, ... , final}`からランダムに1つの値を返す。以下の例で動作を説明する。

* `rand_with_step(-5,5,1)`は$\mathrm{\{-5,-4,-3,-2,-1,0,1,2,3,4,5\}}$からランダムに1つの値を返す。
* `rand_with_step(-5,5,2)` は$\mathrm{\{-5,-3,-1,1,3,5\}}$からランダムに1つの値を返す。
* `rand_with_step(-5,3,3)` は$\mathrm{\{-5,-2,1\}}$からランダムに1つの値を返す。

関数`rand_range(lower,upper,step)`も同じ動作をする。

### rand_with_prohib(lower,upper,list) ###

[lower,upper]の範囲から`list`に含まれる値を除いた整数をランダムに1つ返す。このリストには、`rand_with_step` によって生成された乱数変数も含めることができる。

* `rand_with_prohib(-5,5,[0])`は$\mathrm{\{-5,-4,-3,-2,-1,0,1,2,3,4,5\}}$からランダムに1つの値を返す。
* `rand_with_prohib(-5,5,[-1,0,1,sqrt(pi)])`は$\mathrm{\{-5,-4,-3,-2,2,3,4,5\}}$からランダムに1つの値を返す。
* `rand_with_prohib(-5,3,[-5/2,a])`は$\mathrm{\{-5,-4,-3,-2,-1,0,1,2,3\}}$から$\mathrm{\{a\}}$を除いた集合からランダムに1つの値を返す。

これは行列と組み合わせて使用することもでき、例えば0でない成分のみからなる行列を生成することができる。次の例では、無名関数は引数を無視している。

    matrixmap(lambda([ex],rand_with_prohib(-5,5,[0])),zeromatrix(5,5))；

ランダムな大きさの行列を作成するには、Maximaの`makelist`関数を使用する。

    M1:apply(matrix, makelist(makelist(2^n/3^m, n,1,4), m,1,3));


### rand_selection(ex, n) ###

リストまたは集合`ex`から異なる`n`個の要素をランダムに選択したリストを返す。`ex`に重複が含まれている場合、結果にも重複が含まれる可能性がある。

### rand_selection_with_replacement(ex, n) ###

リストまたは集合`ex`から`n`個の要素を重複を許してランダムに選択したリストを返す。

## ランダムな多項式の生成

以下は、次数が5で係数が0から6のランダムな多項式を生成する例である。

    apply("+",makelist(rand(7)*x^(k-1),k,6))；

## 「まとめて整理する」必要のあるランダムな式の生成

「まとめて整理する」必要のあるランダムな式を生成したいことは比較的よくある。例えば、$\mathrm{2y-y+3y+1}$では、$\mathrm{y}$の項をまとめる必要がある。

    simp:false；
    p:apply("+",makelist(ev(rand_with_prohib(-5,5,[0])*y^rand(2),simp), ev(rand(6)+2,simp)))；
    p:unary_minus_sort(p)；

最初の式の出力は、定数項と変数$\mathrm{y}$からなるランダムな式になる。2行目は単項のマイナスを整理している。この詳細については、[簡約](Simplification.md)を参照すること。

    4*y+5*y+(-2*y)
    4*y+5*y-2*y

## 対応する情報を持つランダムオブジェクト

多くの場合、別々の側面を持つランダムオブジェクトを生成する必要がある。例えば、科学的データを問題文に含める場合である。

    t:rand(5)+3；
    idx:rand(3)+1; /* Maximaの配列インデックスは1から始まり、rand(n)は0,...,n-1を返す。  */
    l1:["Mercury","Earth","Mars"];
    l2:[3.61,9.8,3.75];
    p:l1[idx]；
    ta:t*l2[idx]/(4*%pi^2);

問題文は次のようにできる。

   振り子が {@p@}にあります. 周期が{@t@}秒になるためには、振り子の長さはどれくらいであるべきでしょうか?

この`idx`変数を用いたインデックス指定は非常にロバストである。Maximaのインデックスは、$\mathrm{1}$から始まるのに対して、`rand(n)`が0を返す可能性があることに注意すること。

別の方法は、リストのリストに対して`rand()`を使用することで、オブジェクトの情報をうまくまとめることができる。

    t:rand(5)+3；
    [p, g] : rand(["Mercury",3.61], ["Earth",9.81], ["Mars",3.75])；
    ta:t*g/(4*%pi^2)；

ここで、`rand()`は与えられたリストの中からランダムな1つのリスト、例えば`["Earth",9.81]`を返す。そのときの代入`[p, g] : ["Earth",9.81]` は期待通りに動作する。つまり、`p : "Earth"; g : 9.81;`と同じように機能する。

## 条件を満たすランダムなオブジェクト

制約を満たすランダムなオブジェクトを作成する必要があることはよくある。例えば、「小さい」素数をランダムに生成したい場合は、リストから1つを選ぶだけでよい。

    p:rand([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])；

ランダムに例を生成して最終的に「上手くいく」ものが出てくることを期待するよりも、(i)特定のケースを列挙する、または(ii)条件分岐を避けるように問題を逆算して設計する方がはるかに良い方法である。なぜなら、擬似乱数生成器は問題が生成されるたびにシードから同じ過程を繰り返すからである。ループを入れると、遅延やタイムアウトなどのリスクがある。

以下は推奨されない方法だが、この方法にこだわる人が十分にいるため、ここに記録している。

どうしても必要な場合は（もちろん無限ループになる危険もあるが）、Maximaの`for`コマンドを使用することができる。簡単な例を以下に示す。

    q:1;
    for k while not(is(primep(q))) do block(q:rand(98)+1)；

## 構造化されたランダム行列

STACKには、構造化ランダム行列を作成するための寄稿ライブラリがある。コードは[寄稿ライブラリ](https://github.com/maths/moodle-qtype_stack/blob/master/stack/maxima/contrib/rand_matrix.mac)内でオンライン公開されている。

このライブラリを使用するには、問題変数内で読み込む必要がある。

* サーバー上のローカルコピーを使用する場合：`stack_include("rand_matrix.mac");`
* github から最新のコードを使用する場合： `stack_include_contrib("rand_matrix.mac");`

これらの関数の詳細については、[inclusion](../Authoring/Inclusions.md)のドキュメントを参照すること。

例えば、$\mathrm{3 \times 3}$の可逆行列を生成するには`{@rand_invertible(3)@}`を使用する。

## 関連項目

[Maximaリファレンストピック](index.md#reference)
